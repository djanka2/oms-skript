
<!DOCTYPE html>


<html lang="de" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>5. Praxisaspekte beim Lösen von gemischt-ganzzahligen Programmen &#8212; Optimierungsverfahren, Modellierung und Simulation (DSCB410)</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=384b581d" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css?v=ca93fcec" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script src="_static/documentation_options.js?v=91fba89f"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=efea14e4"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="_static/translations.js?v=70a09b52"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=36754332"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"tex": {"macros": {"N": "\\mathbb{N}", "Z": "\\mathbb{Z}", "R": "\\mathbb{R}", "B": "\\mathbb{B}", "I": "\\mathbb{I}", "E": "\\mathbb{E}", "norm": ["\\left\\lVert#1 \\right\\rVert", 1], "floor": ["\\lfloor#1\\rfloor", 1], "bmat": ["\\begin{pmatrix}"], "emat": ["\\end{pmatrix}"], "bmats": ["\\left(\\begin{smallmatrix}"], "emats": ["\\end{smallmatrix}\\right)"], "scikit": ["\\texttt{scikit-learn}"], "derv": ["\\frac{\\partial #1}{\\partial #2}", 2], "dervquad": ["\\frac{\\partial^2 #1}{\\partial #2^2}", 2], "dervzwei": ["\\frac{\\partial^2 #1}{\\partial {#2} \\partial {#3}}", 3], "v": ["\\mathbf{#1}", 1], "m": ["\\mathbf{#1}", 1], "argmin": ["\\underset{#1}{\\operatorname{arg\\!min}}", 1], "hyper": ["{\\color{Bittersweet}{#1}}", 1], "initial": "\\DeclareMathOperator{\\initial}{initial}", "reduced": "\\DeclareMathOperator{\\reduced}{reduced}", "lazy": "\\DeclareMathOperator{\\lazy}{lazy}", "ILP": "\\DeclareMathOperator{\\ILP}{ILP}", "red": ["{\\color{BrickRed}{#1}}", 1]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '05_Praxisaspekte';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Stichwortverzeichnis" href="genindex.html" />
    <link rel="search" title="Suche" href="search.html" />
    <link rel="next" title="6. Funktionen und Ableitungen" href="06_Multivariate_Analysis.html" />
    <link rel="prev" title="4.5. Anwendung: Energiespeicherproblem mit rollierendem Zeitfenster" href="04_Speicherproblem_rollierend.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="de"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="00_Ueberblick.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/HKA_IWI_Bildmarke-h_RGB.svg" class="logo__image only-light" alt="Optimierungsverfahren, Modellierung und Simulation (DSCB410) - Home"/>
    <script>document.write(`<img src="_static/HKA_IWI_Bildmarke-h_RGB.svg" class="logo__image only-dark" alt="Optimierungsverfahren, Modellierung und Simulation (DSCB410) - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Suche" aria-label="Suche" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Suche</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="00_Ueberblick.html">
                    Überblick
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Lineare Optimierungsmodelle</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="01_Grundbegriffe.html">1. Einführung und Grundbegriffe</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="02_Lineare_Probleme.html">2. Lineare Optimierung</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="02_Transportproblem.html">2.9. Anwendung: Transportproblem</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="03_Ganzzahlige_Probleme.html">3. Ganzzahlige Probleme</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="03_Standortprobleme.html">3.8. Anwendung: Standortprobleme</a></li>
<li class="toctree-l2"><a class="reference internal" href="03_Zuordnung_AWP.html">3.9. Anwendung: Studierende auf Projekte verteilen</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="04_Dynamische_Probleme.html">4. Zeitabhängige Probleme</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="04_Laststeuerung.html">4.4. Anwendung: Laststeuerung in der Stahlproduktion</a></li>
<li class="toctree-l2"><a class="reference internal" href="04_Speicherproblem_rollierend.html">4.5. Anwendung: Energiespeicherproblem mit rollierendem Zeitfenster</a></li>
</ul>
</li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">5. Praxisaspekte beim Lösen von gemischt-ganzzahligen Programmen</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Ableitungsbasierte Optimierung</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="06_Multivariate_Analysis.html">6. Funktionen und Ableitungen</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_Theoretische_Grundlagen.html">7. Grundlagen der nichtlinearen Optimierung</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="08_Quadratische_Probleme.html">8. Quadratische Probleme</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="08_Lineare_Regression.html">8.4. Anwendung: Lineare Regressionsprobleme</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="09_Automatische_Differentiation.html">9. Automatische Differentiation</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="10_Gradientenverfahren.html">10. Verfahren erster Ordnung</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="10_Logistische_Regression.html">10.9. Logistische Regression</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="11_Verfahren_zweiter_Ordnung.html">11. Verfahren zweiter Ordnung</a></li>
<li class="toctree-l1"><a class="reference internal" href="12_Stochastischer_Gradientenabstieg.html">12. Stochastischer Gradientenabstieg</a></li>
<li class="toctree-l1"><a class="reference internal" href="13_Training_NN.html">13. Training von Neuronalen Netzen</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Laden Sie diese Seite herunter">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/05_Praxisaspekte.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Quelldatei herunterladen"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="In PDF drucken"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Vollbildmodus"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Suche" aria-label="Suche" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Praxisaspekte beim Lösen von gemischt-ganzzahligen Programmen</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Inhalt </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#marktubersicht-milp-solver">5.1. Marktübersicht MILP-Solver</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ubersicht">5.1.1. Übersicht</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#benchmarks">5.1.2. Benchmarks</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#modellierungsumgebungen">5.1.3. Modellierungsumgebungen</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#moglichkeiten-zur-beschleunigung-des-losungsverfahrens">5.2. Möglichkeiten zur Beschleunigung des Lösungsverfahrens</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#allgemeine-kriterien-fur-die-bewertung-eines-modells">5.2.1. Allgemeine Kriterien für die Bewertung eines Modells</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#modellgrosze">Modellgröße</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#laufzeit-der-modellerzeugung">Laufzeit der Modellerzeugung</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#numerische-stabilitat">Numerische Stabilität</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#scharfe-der-lp-relaxierung">Schärfe der LP-Relaxierung</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parametereinstellungen-des-losers">5.2.2. Parametereinstellungen des Lösers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#heuristiken-und-dekompositionen">5.2.3. Heuristiken und Dekompositionen</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#zeitfenster">5.2.4. Zeitfenster</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#rollierende-planung">Rollierende Planung</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#partitionierung-der-zeitachse-in-intervalle">Partitionierung der Zeitachse in Intervalle</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#angrenzende-intervalle-mit-vorschauperiode">Angrenzende Intervalle mit Vorschauperiode</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#interpretation-der-solver-ausgaben">5.3. Interpretation der Solver-Ausgaben</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="praxisaspekte-beim-losen-von-gemischt-ganzzahligen-programmen">
<span id="sec-practical-aspects"></span><h1><span class="section-number">5. </span>Praxisaspekte beim Lösen von gemischt-ganzzahligen Programmen<a class="headerlink" href="#praxisaspekte-beim-losen-von-gemischt-ganzzahligen-programmen" title="Link to this heading">#</a></h1>
<section id="marktubersicht-milp-solver">
<h2><span class="section-number">5.1. </span>Marktübersicht MILP-Solver<a class="headerlink" href="#marktubersicht-milp-solver" title="Link to this heading">#</a></h2>
<p>Es gibt eine größere Anzahl an brauchbaren kommerziellen und nichtkommerziellen Softwaretools zum Lösen von gemischt-ganzzahligen Programmen.
Die kommerziellen Anwendungen weisen hierbei typischerweise deutlich höhere Lösungsgeschwindigkeiten auf. Dem Dozenten ist kein aktueller unabhängiger umfassender wissenschaftlicher Vergleich zwischen den einzelnen Software-lösungen bekannt.</p>
<section id="ubersicht">
<h3><span class="section-number">5.1.1. </span>Übersicht<a class="headerlink" href="#ubersicht" title="Link to this heading">#</a></h3>
<p>Bekannte kommerzielle Anwendungen sind etwa CLEX, GUROBI und XPRESS, bekannte Open-Source Lösungen sind etwa CBC, LPSolve und SCIP.
Eine nicht qualitätsgesicherte, aber zum Stand 01.04.2020 brauchbare Auflistung aktueller Softwaretools findet sich in der Wikipedia unter
<a class="reference external" href="https://en.wikipedia.org/wiki/List_of_optimization_software">List of Optimization Software</a>.</p>
</section>
<section id="benchmarks">
<h3><span class="section-number">5.1.2. </span>Benchmarks<a class="headerlink" href="#benchmarks" title="Link to this heading">#</a></h3>
<p>Zum Stand vom 01.04.2020 erlaubt der
<a class="reference external" href="https://neos-server.org/neos/">NEOS Server</a>
Probleme kostenlos durch verschiedenene Solver zu lösen.</p>
<p>Ein etwas älteres Benchmark der Solver CPLEX, GUROBI und XPRESS findet sich in \emph{Josef Jablonsky: Benchmarks for current linear and mixed integer optimization solvers, Acta Universitatis Agriculturae et Silviculturae Mendelianae Brunensis, 2015}.</p>
<p>Weitere Benchmarks werden regelmäßig unter
<a class="reference external" href="http://plato.asu.edu/bench.html">http://plato.asu.edu/bench.html</a> veröffentlicht.
Diese enthalten seit 2018 keine Resultate für CPLEX, Gurobi und XPRESS (siehe \emph{Hans Mittelmann: Benchmarking Optimization Software - a (Hi)Story, SN Operations Research Forum, 2020}).</p>
<p>Der folgende Auszug stammt aus den Vortragsfolien zu
<em>Hans Mittelmann, Latest Benchmarks of Optimization Software, INFORMS Annual Meeting, Houston, 2017</em>.</p>
<figure class="align-default" id="benchmarkmittelmann2017">
<a class="reference internal image-reference" href="_images/BenchmarkMittelmann2017.png"><img alt="_images/BenchmarkMittelmann2017.png" src="_images/BenchmarkMittelmann2017.png" style="height: 300px;" /></a>
</figure>
<figure class="align-default" id="benchmarkmittelmann2017-2">
<a class="reference internal image-reference" href="_images/BenchmarkMittelmann2017_2.png"><img alt="_images/BenchmarkMittelmann2017_2.png" src="_images/BenchmarkMittelmann2017_2.png" style="height: 300px;" /></a>
</figure>
<figure class="align-default" id="benchmarkmittelmann2017-3">
<a class="reference internal image-reference" href="_images/BenchmarkMittelmann2017_3.png"><img alt="_images/BenchmarkMittelmann2017_3.png" src="_images/BenchmarkMittelmann2017_3.png" style="height: 300px;" /></a>
</figure>
</section>
<section id="modellierungsumgebungen">
<h3><span class="section-number">5.1.3. </span>Modellierungsumgebungen<a class="headerlink" href="#modellierungsumgebungen" title="Link to this heading">#</a></h3>
<p>Zusätzlich gibt es Modellierungsumgebungen, die es ermöglichen, Modelle unabhängig von einem konkreten Löser zu erzeugen. Dies erlaubt ein einfaches Austauschen des konkreten Lösers.
Unter Umständen können diese Umgebungen nicht auf alle Eigenheiten oder Features eines speziellen Lösers zugreifen.
Je nach Kombination aus Solver und Modellierungsumgebung erlaubt die Umgebung auch eine komfortablere Erstellung des Modells.</p>
<p>Bekannte solche Frameworks sind etwa AIMMS, AMPL, GAMS, JuMP, PuLP, Pyomo.</p>
</section>
</section>
<section id="moglichkeiten-zur-beschleunigung-des-losungsverfahrens">
<h2><span class="section-number">5.2. </span>Möglichkeiten zur Beschleunigung des Lösungsverfahrens<a class="headerlink" href="#moglichkeiten-zur-beschleunigung-des-losungsverfahrens" title="Link to this heading">#</a></h2>
<p>Ein kritischer Aspekt bei der Arbeit mit gemischt-ganzzahligen Programmen ist die Rechenzeit die zur Lösung eines Modells benötigt wird.
Das effiziente Lösen von gemischt-ganzzahligen Programmen ist ein weites Forschungsfeld, das eine reichhaltige und tiefgehende theoretische Basis entwickelt hat.</p>
<p>Moderne Löser arbeiten typischerweise mit einem Branch-And-Bound Verfahren, dass um eine eine große Anzahl an heuristischen Methoden zur Laufzeitverbesserung erweitert wurde. Zusätzlich ist der Einsatz einer Presolve-Methode Standard.
Die konkret vorliegende Hardwarekonfiguration hat einen zusätzlichen Einfluss auf die Lösungsgeschwindigkeit.
Aus diesem Grund ist das Laufzeitverhalten für ein bestimmtes Modell nicht komplett vorhersagbar.
Im Folgenden skizzieren wir einige allgemeine Gedanken und Ansatzpunkte, mit denen die Rechenzeit in der Praxis verbessert werden kann.</p>
<section id="allgemeine-kriterien-fur-die-bewertung-eines-modells">
<span id="subsubsec-kriterienbewertung"></span><h3><span class="section-number">5.2.1. </span>Allgemeine Kriterien für die Bewertung eines Modells<a class="headerlink" href="#allgemeine-kriterien-fur-die-bewertung-eines-modells" title="Link to this heading">#</a></h3>
<section id="modellgrosze">
<h4>Modellgröße<a class="headerlink" href="#modellgrosze" title="Link to this heading">#</a></h4>
<p>Ein erstes wichtiges Kriterium für die Bewertung eines Modells ist seine Größe.
Diese kann in der Anzahl der Variablen gemessen werden.</p>
<p>Wichtig ist eine Unterscheidung in kontinuierliche und ganzzahlige Variablen.
Kontinuierliche Variablen können effizient durch das Simplex-Verfahren bestimmt werden.
Diskrete Variablen hingegen verursachen typischerweise den Hauptrechenaufwand, da sie durch ein aufwendigeres Branch-And-Bound Verfahren bestimmt werden müssen.</p>
<p>Bei manchen Modellen macht es zusätzlich Sinn, die Anzahl der Nebenbedingungen zu betrachten.</p>
</section>
<section id="laufzeit-der-modellerzeugung">
<h4>Laufzeit der Modellerzeugung<a class="headerlink" href="#laufzeit-der-modellerzeugung" title="Link to this heading">#</a></h4>
<p>Der Grund für einen langsamen Gesamtlösungsprozess muss nicht unbedingt in der Laufzeit des mathematischen Lösers selbst liegen.
Bei ineffizienter Programmierung oder langsamer Datenbereitstellung kann der Hauptteil der Rechenzeit durch das Erstellen des Modells anstatt durch das Lösen verursacht werden.</p>
<p>Als professionelle Diagnosetools stehen für die meisten Programmiersprachen sogenannte <em>Profiler</em> bereit, die die Programmlaufzeit nach Einzelroutinen aufschlüsseln können.  Häufig genügt zur Diagnose allerdings auch ein Lauf des Programmcodes, bei dem der finale Aufruf des Lösers auskommentiert ist.</p>
</section>
<section id="numerische-stabilitat">
<h4>Numerische Stabilität<a class="headerlink" href="#numerische-stabilitat" title="Link to this heading">#</a></h4>
<p>Mathematische Löser für gemischt-ganzzahlige Programme arbeiten nicht mit exakten Zahlen, sondern nutzen die in Computern übliche Fließkommaarithmetik mit beschränkter Genauigkeit. Häufig stellt dies kein Problem dar.</p>
<p>Wenn die Größenordnungen der Eingabewerte stark unterschiedlich sind, kann es zu numerischen Problemen kommen.
Ein Vergleich von kleinstem und größtem vorkommenden Eingabewert gibt einen erstes Indiz dafür, ob das Problem numerisch schwierig zu lösen ist.</p>
</section>
<section id="scharfe-der-lp-relaxierung">
<h4>Schärfe der LP-Relaxierung<a class="headerlink" href="#scharfe-der-lp-relaxierung" title="Link to this heading">#</a></h4>
<p>Wir haben in Abschnitt <a class="reference internal" href="03_Ganzzahlige_Probleme.html#subsec-disjunctiveprogramming"><span class="std std-ref">Oder-Verknüpfung für Nebenbedingungen</span></a> gesehen, dass Modelle die den gleichen zulässigen Lösungsraum beschreiben, sich trotzdem durch die Schärfe ihrer LP-Relaxierung unterscheiden können.
Es gibt tiefgehende Theorie, um den zu einem linearen Programm zugehörigen Lösungspolyeder zu beschreiben.</p>
<p>Einen guten ersten Eindruck zur Güte der LP-Relaxierung kann man durch die <em>Ganzzahligkeitslücke</em> (engl: integrality gap) gewinnen.</p>
<div class="proof definition admonition" id="definition-0">
<p class="admonition-title"><span class="caption-number">Definition 5.1 </span> (Ganzzahligkeitslücke)</p>
<section class="definition-content" id="proof-content">
<p>Gegeben ist ein gemischt-ganzzahliges Programm MILP mit optimaler Lösung <span class="math notranslate nohighlight">\(f^*\)</span> und das zu MILP relaxierte Problem LP mit optimaler Lösung <span class="math notranslate nohighlight">\(f^*_{rel}\)</span>. Die Ganzzahligkeitslücke von MILP ist
<span class="math notranslate nohighlight">\({f^*}/{f^*_{rel}}\)</span> falls MILP ein Minimierungsproblem ist und <span class="math notranslate nohighlight">\({f^*_{rel}}/{f^*}\)</span> sonst.</p>
</section>
</div><p>Die Ganzzahligkeitslücke ist mindestens <span class="math notranslate nohighlight">\(1\)</span>. Kleinere Werte sind im Allgemeinen besser.</p>
<div class="proof example admonition" id="example-1">
<p class="admonition-title"><span class="caption-number">Example 5.1 </span></p>
<section class="example-content" id="proof-content">
<p>TO DO</p>
</section>
</div></section>
</section>
<section id="parametereinstellungen-des-losers">
<h3><span class="section-number">5.2.2. </span>Parametereinstellungen des Lösers<a class="headerlink" href="#parametereinstellungen-des-losers" title="Link to this heading">#</a></h3>
<p>Die heuristischen Vorgehen innerhalb moderner Löser arbeiten mit guten Voreinstellungen, die auf konkrete Instanzen ohne Programmierarbeit angepasst werden können. Die Einstellungs-möglichkeiten variieren für verschiedene Löser. Beispielhaft folgt eine Übersicht für den kommerziellen Solver Gurobi (Quelle: <a class="reference external" href="https://www.gurobi.com/documentation/9.0/refman/mip_models.html">www.gurobi.com</a>, abgerufen am  31.03.2020).</p>
<figure class="align-default" id="gurobi-parameters-chunk1">
<a class="reference internal image-reference" href="_images/Gurobi_parameters_chunk1.png"><img alt="_images/Gurobi_parameters_chunk1.png" src="_images/Gurobi_parameters_chunk1.png" style="height: 300px;" /></a>
</figure>
<figure class="align-default" id="gurobi-parameters-chunk2">
<a class="reference internal image-reference" href="_images/Gurobi_parameters_chunk2.png"><img alt="_images/Gurobi_parameters_chunk2.png" src="_images/Gurobi_parameters_chunk2.png" style="height: 300px;" /></a>
</figure>
</section>
<section id="heuristiken-und-dekompositionen">
<h3><span class="section-number">5.2.3. </span>Heuristiken und Dekompositionen<a class="headerlink" href="#heuristiken-und-dekompositionen" title="Link to this heading">#</a></h3>
<p>Ist es nicht möglich, ein Modell in akzeptabler Zeit optimal zu lösen, liegt eine mögliche Strategie im Einsatz von Heuristiken. Man nimmt dann davon Abstand, beweisbar optimale Lösungen zu finden, sondern hofft auf ausreichend gute Ergebnisse.</p>
<p>Ein häufiges heuristisches Vorgehen in Zusammenhang mit gemischt-ganzzahligen Programmen ist das der <em>Problemdekomposition</em>.
Dabei werden nicht mehr alle Entscheidungsvariablen “gleichzeitig” bestimmt.
Stattdessen wird das Problem in verschiedene Ebenen unterteilt, die nacheinander gelöst werden.
Jede Ebene legt eine bestimme Menge an Entscheidungsvariablen fest, die von den unterliegenden Ebenen nicht mehr revidiert werden können.</p>
<p>Wir betrachten dies am Beispiel des Vehicle-Routing Problems.
Sogenannte Cluster-First Route-Second Ansätze entscheiden zuerst, welche Orte zu Touren zusammengefasst werden (erste Ebene).
Danach werden die Touren einzeln as Traveling Salesman Instanzen gelöst (zweite Ebene).</p>
<div class="proof example admonition" id="example-2">
<p class="admonition-title"><span class="caption-number">Example 5.2 </span></p>
<section class="example-content" id="proof-content">
<p>TO DO</p>
</section>
</div></section>
<section id="zeitfenster">
<h3><span class="section-number">5.2.4. </span>Zeitfenster<a class="headerlink" href="#zeitfenster" title="Link to this heading">#</a></h3>
<p>Ein spezielles Dekompositionsverfahren für zeitexpandierte Modelle sind die sogenannten <em>Zeitfenster</em>.
Diese heißen im Engischen <em>time windows</em>.
Hierbei wird die Zeitachse in mehrere Intervalle zerlegt, die nacheinander gelöst werden.
Dabei baut jedes Zeitfenster auf der Situation des vorhergehenden Zeitfensters auf.
Entscheidungen, die vor Beginn des aktuellen Zeitfensters liegen, sind fest und können nicht mehr geändert werden.
Die Situation nach dem aktuellen Zeitfenster wird für dieses nicht berücksichtigt, sondern erst in den folgenden Zeitfenstern.</p>
<p><em>Wichtig:</em> Der Einsatz von Zeitfenstern ist eine Heuristik. Es kann nicht  garantiert werden, dass die optimale Lösung für das ursprüngliche Problem gefunden wird.</p>
<section id="rollierende-planung">
<h4>Rollierende Planung<a class="headerlink" href="#rollierende-planung" title="Link to this heading">#</a></h4>
<p>Es gibt verschiedene Möglichkeiten, Zeitfenster zu realisieren. Eine Möglichkeit sind <em>rollierende Fenster</em>, bei denen das Fenster in jedem Schritt nur um wenige Zeitschritte nach vorne bewegt wird.</p>
<div class="proof example admonition" id="example-3">
<p class="admonition-title"><span class="caption-number">Example 5.3 </span></p>
<section class="example-content" id="proof-content">
<p>TO DO</p>
</section>
</div></section>
<section id="partitionierung-der-zeitachse-in-intervalle">
<h4>Partitionierung der Zeitachse in Intervalle<a class="headerlink" href="#partitionierung-der-zeitachse-in-intervalle" title="Link to this heading">#</a></h4>
<p>Eine Möglichkeit, um weniger Zeitfenster lösen zu müssen ist, die Zeitachse in disjunkte, aneinander angrenzende Intervalle aufzuteilen.</p>
<div class="proof example admonition" id="example-4">
<p class="admonition-title"><span class="caption-number">Example 5.4 </span></p>
<section class="example-content" id="proof-content">
<p>TO DO</p>
</section>
</div><p>Häufig sind die Ergebnisse dieser Methode nicht zufriedenstellend, da an den Intervallgrenzen unerwünschte Effekte auftreten.
Auf der nächsten Seite findet sich ein solcher Zeitfenster-Ansatz für das Speicheroptimierungsproblem aus Kapitel <a class="reference internal" href="04_Dynamische_Probleme.html#sec-zeitdiskret"><span class="std std-ref">Zeitabhängige Probleme</span></a>. Wir sehen, dass zu Ende jedes Zeitfensters, die Batterie komplett geleert wird.
Dies macht für das konkrete Zeitfenster Sinn, da so Kosten innerhalb des Fensters gespart werden.
Es führt allerdings typischerweise zu suboptimalen Lösungen für das Gesamtproblem.</p>
</section>
<section id="angrenzende-intervalle-mit-vorschauperiode">
<h4>Angrenzende Intervalle mit Vorschauperiode<a class="headerlink" href="#angrenzende-intervalle-mit-vorschauperiode" title="Link to this heading">#</a></h4>
<p>Eine Lösung für das vorangegangene Problem ist der zusätzliche Einsatz einer Vorschauperiode.
Hierbei enthält jedes Zeitfenster einen zusätzlichen Zeitraum, der an das Ende des Fensters angehängt wird.
Das Optimierungsproblem umfasst das eigentliche Intervall, zusammen mit der Vorschauperiode und optimiert beides.
Es werden nur die Entscheidungen für das eigentliche Intervall festgehalten.
Die Entscheidungen der Vorschauperiode werden verworfen.
Die Vorschauperiode ist dann Teil des nächsten Zeitfensters. Ein Beispiel findet sich hier: <a class="reference internal" href="#batteriezeitfenster-ohnelookahead"><span class="std std-ref">Zeitfensteransatz für das Problem aus Kapitel sec:zeitdiskret ohne Vorschauperiode.</span></a>.</p>
<div class="proof example admonition" id="example-5">
<p class="admonition-title"><span class="caption-number">Example 5.5 </span></p>
<section class="example-content" id="proof-content">
<p>TO DO</p>
</section>
</div><figure class="align-default" id="batteriezeitfenster-ohnelookahead">
<a class="reference internal image-reference" href="_images/BatterieZeitfenster_OhneLookAhead.png"><img alt="_images/BatterieZeitfenster_OhneLookAhead.png" src="_images/BatterieZeitfenster_OhneLookAhead.png" style="height: 300px;" /></a>
<figcaption>
<p><span class="caption-number">Abb. 5.1 </span><span class="caption-text">Zeitfensteransatz für das Problem aus Kapitel <a class="reference internal" href="04_Dynamische_Probleme.html#sec-zeitdiskret"><span class="std std-ref">Zeitabhängige Probleme</span></a> ohne Vorschauperiode.</span><a class="headerlink" href="#batteriezeitfenster-ohnelookahead" title="Link to this image">#</a></p>
</figcaption>
</figure>
<figure class="align-default" id="batteriezeitfenster-mitlookahead">
<a class="reference internal image-reference" href="_images/BatterieZeitfenster_MitLookAhead.png"><img alt="_images/BatterieZeitfenster_MitLookAhead.png" src="_images/BatterieZeitfenster_MitLookAhead.png" style="height: 300px;" /></a>
<figcaption>
<p><span class="caption-number">Abb. 5.2 </span><span class="caption-text">Zeitfensteransatz für das Problem aus Kapitel <a class="reference internal" href="04_Dynamische_Probleme.html#sec-zeitdiskret"><span class="std std-ref">Zeitabhängige Probleme</span></a> mit Vorschauperiode.</span><a class="headerlink" href="#batteriezeitfenster-mitlookahead" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Rollierende Planung für das Beispielmodel aus Kapitel <a class="reference internal" href="04_Dynamische_Probleme.html#sec-zeitdiskret"><span class="std std-ref">Zeitabhängige Probleme</span></a>.</p>
<div class="proof example admonition" id="example-6">
<p class="admonition-title"><span class="caption-number">Example 5.6 </span></p>
<section class="example-content" id="proof-content">
<p>TO DO</p>
</section>
</div></section>
</section>
</section>
<section id="interpretation-der-solver-ausgaben">
<h2><span class="section-number">5.3. </span>Interpretation der Solver-Ausgaben<a class="headerlink" href="#interpretation-der-solver-ausgaben" title="Link to this heading">#</a></h2>
<p>Die Ausgaben des Lösers liefern wichtige diagnostische Informationen.
Im Folgenden sehen wir die Ausgaben für das Modell aus Abschnitt <span class="xref std std-ref">subsub:lazyConstraints</span>.</p>
<figure class="align-default" id="gurobi-solveroutput2-1">
<img alt="_images/Gurobi_SolverOutput2_1.png" src="_images/Gurobi_SolverOutput2_1.png" />
</figure>
<p>Wir sehen, dass das Modell <span class="math notranslate nohighlight">\(2550\)</span> Entscheidungsvariablen enthält von denen <span class="math notranslate nohighlight">\(0\)</span> kontinuierlich, <span class="math notranslate nohighlight">\(1250\)</span> binär und <span class="math notranslate nohighlight">\(1250\)</span> ganzzahlig sind.
Die Matrix <span class="math notranslate nohighlight">\(A\)</span> besteht aus 50 Zeilen und 1275 Spalten - es sind aber nur 2500 Einträge ungleich <span class="math notranslate nohighlight">\(0\)</span>.
Wir vergleichen diese Zahlen mit den von uns erwarteten Werten.
Dies ist ein erster einfacher Test, ob das Modell richtig implementiert ist.
Wir erkennen zusätzlich, dass Lazy Constraints aktiv sind.</p>
<figure class="align-default" id="gurobi-solveroutput2-2">
<img alt="_images/Gurobi_SolverOutput2_2.png" src="_images/Gurobi_SolverOutput2_2.png" />
</figure>
<p>Alls vorkommenden Zahlen liegen jeweils in der gleichen Größenordnung.
Wäre das berichtete Intervall für eine Kategorie sehr groß, wäre dies in Hinweis auf mögliche spätere numerische Probleme beim Lösen des linearen Programms.</p>
<figure class="align-default" id="gurobi-solveroutput2-3">
<img alt="_images/Gurobi_SolverOutput2_3.png" src="_images/Gurobi_SolverOutput2_3.png" />
</figure>
<p>Der Solver hat über eine Heuristik eine erste zulässge Lösung gefunden bevor mit dem eigentlichen Lösungsprozess gestartet wurde.
Wir wissen also, dass die optimale Lösung einen Zielfunktionswert von höchstens 2775.3416544 hat.
Dieser Wert wird als obere Schranke für den weiteren Lösungsprozess benutzt und kann damit den Lösungsprozess beschleunigen.</p>
<p>Wird vorab keine zulässige Lösung gefunden, kann der Lösungsprozess möglicherweise beschleunigt werden, indem man durch Kenntnis des konkreten Problems mit wenig Rechenaufwand außerhalb des gemischt-ganzzahligen Modells eine zulässige Lösung findet und dem Solver vorab übermittelt. Dieses Vorgehen ist allerdings nicht immer möglich.</p>
<figure class="align-default" id="gurobi-solveroutput2-4">
<img alt="_images/Gurobi_SolverOutput2_4.png" src="_images/Gurobi_SolverOutput2_4.png" />
</figure>
<p>Die Presolve-Routine hat das Modell etwas verkleinern können. Die Modellgröße nach der Presolve-Routine ist ein guter Kennwert für die Größe des Modells.</p>
<figure class="align-default" id="gurobi-solveroutput2-5">
<img alt="_images/Gurobi_SolverOutput2_5.png" src="_images/Gurobi_SolverOutput2_5.png" />
</figure>
<p>Der Löser startet nun mit der eigentlichen Suche. Zu Beginn des Suchbaums wird das relaxierte Problem gelöst (die sogenannte root relaxation).
Diese ergibt in 71 Iterationen die untere Schranke von 598.1996.</p>
<p>Die Lösungsdauer der Root Relaxation ist mit 0.01 Sekunden unkritisch.
Bei einer deutlich längeren Rechenzeit würden zusätzliche diagnostische Informationen zur Root Relaxation angezeigt werden.</p>
<figure class="align-default" id="gurobi-solveroutput2-6">
<img alt="_images/Gurobi_SolverOutput2_6.png" src="_images/Gurobi_SolverOutput2_6.png" />
</figure>
<p>Dieser Teil beschreibt den Verlauf des Branch-And-Bound Verfahrens. In festen Zeitabständen wird eine neue Zeile generiert, die Aufschluss über den aktuellen Zustand des aktuellen Suchbaums gibt.
Die Spalten bedeuten im Einzelnen</p>
<ul class="simple">
<li><p>Die 1. Spalte enthält ein h oder ein * falls seit der letzten Zeile eine neue zulässige Lösung gefunden wurde.</p></li>
<li><p>Die 2. Spalte enthält die Anzahl der fertig abgearbeiteten Knoten im Suchbaum.</p></li>
<li><p>Die 3. Spalte enthält die Anzahl der noch zu bearbeitenden Blätter im Suchbaum.</p></li>
<li><p>Die Spalten 4-6 beschreiben den aktuell bearbeiteten Knoten im Suchbaum.</p>
<ul>
<li><p>Der Wert der Relaxierung,</p></li>
<li><p>Die Tiefe im Suchbaum,</p></li>
<li><p>Die Anzahl der fraktionalen ganzzahligen Variablen.</p></li>
</ul>
</li>
<li><p>Die Spalten 7-9 beschreiben die Güte der bisher gefundenen Lösung.</p>
<ul>
<li><p>Der Lösungswert der besten bisher gefundenen zulässigen Lösung,</p></li>
<li><p>Die beste bisher bewiesene Schranke,</p></li>
<li><p>Der Wert (<span class="math notranslate nohighlight">\(|\)</span>beste gefundene Lösung - beste gefundene Schranke<span class="math notranslate nohighlight">\(|\)</span>) / beste gefundene Lösung.</p></li>
</ul>
</li>
<li><p>Die 10. Spalte zeigt die Anzahl der durchschnittlichen Simplex-Operationen pro Knoten.</p></li>
<li><p>Die 11. Spalte zeigt die Laufzeit des Branch-And-Bound Verfahrens bis zum aktuellen Stand.</p></li>
</ul>
<figure class="align-default" id="gurobi-solveroutput2-7">
<img alt="_images/Gurobi_SolverOutput2_7.png" src="_images/Gurobi_SolverOutput2_7.png" />
</figure>
<p>Der Löser hat während des Lösungsprozesses zusätzliche Nebenbedingungen, sogenannte Schnittebenen (\emph{cuts}) hinzugefügt, die die optimale Lösung nicht ändern, aber zu einem schnelleren Lösungsprozess führen sollen. Die Aufschlüsselung dieser folgt nach verschiedenen Klassen von Schnittebenen.</p>
<p>Außerdem wurden insgesamt 8 Lazy-Constraints hinzugefügt. Durch die geringe nötige Anzahl an Lazy-Constraints erkennt man, dass der Einsatz von diesen für die aktuelle Instanz sinnvoll ist.</p>
<figure class="align-default" id="gurobi-solveroutput2-8">
<img alt="_images/Gurobi_SolverOutput2_8.png" src="_images/Gurobi_SolverOutput2_8.png" />
</figure>
<p>Der fertige Branch-And-Bound Baum besteht aus 22 Knoten.
Insgesamt wurden 494 Simplex-Schritte an den Knoten ausgeführt.
Es wurden alle 8 Kerne benutzt.
Die Rechenzeit für das Branch-And-Bound Verfahren war 0.48 Sekunden.
Insgesamt wurden während des Lösungsprozesses 7 zulässige Lösungen im Zahlenbereich von 635 bis 2775 gefunden.</p>
<figure class="align-default" id="gurobi-solveroutput2-9">
<img alt="_images/Gurobi_SolverOutput2_9.png" src="_images/Gurobi_SolverOutput2_9.png" />
</figure>
<p>Es gilt</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\frac{|\text{Wert der besten gefundenen Lösung - Wert der schärfsten unteren Schranke}|}{|\text{Wert der besten gefundenen Lösung}|} =0
\end{align*}\]</div>
<p>Damit wurde die optimale Lösung gefunden.
Als Abbruchtoleranz war <span class="math notranslate nohighlight">\(0.0004\)</span> eingestellt, d.h. das Lösungsverfahren bricht ab, wenn dieser Quotient kleiner als <span class="math notranslate nohighlight">\(0.0004\)</span> ist.
Die bis dahin gefundene beste zulässige Lösung wird dann als Ergebnis gemeldet, ist aber möglicherweise nicht optimal.</p>
<p>Die gefundene Lösung hat einen Zielfunktionswert von 635.5025787588.
Die beste gefundene untere Schranke für den Zielfunktionswert ist 635.5025787588.</p>
<p>Auf der nächsten Seite findet sich die komplette Ausgabe für das Modell.</p>
<figure class="align-default" id="gurobi-solveroutput2">
<img alt="_images/Gurobi_SolverOutput2.png" src="_images/Gurobi_SolverOutput2.png" />
</figure>
<!-- 
# Fortgeschrittene Themen

## Rundreiseprobleme

(subsubsec:TSP)=
### Das Problem des Handelsreisenden

Das Problem des Handelsreisenden heißt im Englischen *traveling salesman problem* oder *traveling salesperson problem*.

Gegeben sind $n$ Orte zusammen mit einer Entfernungs- oder Kostenmatrix $C$, die die paarweise Distanz zwischen den jeweiligen Orten angibt. Alle Entfernungen sind nicht-negativ. Ein Handlungsreisender möchte alle $n$ Orte besuchen und danach wieder zu seinem Startort zurückkehren. Dies bezeichnet man als *geschlossene Rundreise*. 
Gesucht ist eine geschlossene Rundreise von minimaler Gesamtstrecke unter allen geschlossenen Rundreisen.

````{prf:example}
TO DO
````

Eine Permutation $\pi_1, \pi_2, \ldots, \pi_n$ der Zahlen $\{1, 2, \ldots, n\}$ ist eine Umsortierung von $\{1, 2, \ldots, n\}$.[^fn:perm] 

[^fn:perm]: Formal definiert ist eine Permutation von $\{1, 2, \ldots, n\}$ eine umkehrbare Abbildung von $\{1, 2, \ldots, n\}$ auf $\{1, 2, \ldots, n\}$. 

````{prf:example}
TO DO
````

Wir suchen also eine bestimmte Permutation der Orte. 

````{prf:definition} Problem des Handlungsreisenden
Instanz
: Eine Menge $C=\{1, 2, \ldots, n\}$ aus $n$ Orten und eine Distanzfunktion $d(c_i,c_j) \in \R^+$ auf $C$.

Aufgabe
: Gesucht ist eine kürzeste Rundreise auf $C$, d.h. eine Permutation $\pi_1, \pi_2, \ldots, \pi_n$ von $C$, so dass 

\begin{align*}\left(\sum_{i=1}^{n-1} d(\pi_i,\pi_{i+1}) \right) + d(\pi_n,\pi_1) \end{align*}

minimal ist.  
````

Wir betrachten folgende Probleminstanz
````{prf:example}
TO DO
````
Wir setzen für unsere Modellierung die Entscheidungsvariablen 
````{prf:example}
TO DO
````
ein. 
%Um sicherzustellen, dass jeder Ort genau einmal besucht wird, können wir folgende Nebenbedingungen nutzen.
%\Karos{33}{9}
Als erstes (unvollständiges!) Modell ergibt sich
````{prf:example}
TO DO
````

Wir erkennen, dass die Problemformulierung noch nicht vollständig ist. Es können sich sogenannte *Subtouren* bilden:
````{prf:example}
TO DO
````
Wie verhindern wir Subtouren? Es gibt zwei verschieden Ansätze. 

#### Das Modell nach Dantzig, Fulkerson und Johnson
Das Modell setzt folgende Nebenbedingungen zur Elimination von Subtouren ein:

\begin{align*}\sum_{i \in C'} \sum_{j \in C'}x_{ij} \leq |C'|-1 \hspace{1cm} \forall C' \subset \{2, \ldots, n\}, \hspace{0.3cm} |C'| \geq 2 \end{align*}

````{prf:example}
TO DO
````
Es wird also für jede mögliche Teilmenge $C'$ an Städten sichergestellt, dass "ein Weg in $C'$ führt". Der Ort $1$ wird als Startort der Reise angesehen und benötigt keine Nebenbedingung, da $C'= \{2, \ldots, n\}$ sicherstellt, dass $1$ in der Tour enthalten ist. Insgesamt ergibt sich das folgende Modell:
````{prf:example}
TO DO
````
Es gibt sehr viele Teilmengen von $C$. Damit besitzt dieses Modell sehr viele Nebenbedingungen, wenn die Anzahl der Städte groß ist.

#### Das Modell nach Miller, Tucker und Zemlin
Das Modell setzt zusätzliche reellwertige Variablen $u_i$ ein, die die Orte in der Reihenfolge der Tour durchnummerieren:
%\begin{align*}u_i - u_j + nx_{ij} \leq n-1 \hspace{1cm} i,j \in \{2, \ldots, n\} \hspace{0.3cm} i \not=j \end{align*}
\begin{alignat*}{8}
u_i - u_j + nx_{ij} & \leq &&  \ n-1  \hspace{1cm} && i,j \in \{2, \ldots, n\} \hspace{0.3cm} i \not=j \\
u_1 & = && \ 1 \\
2 \leq u_i & \leq && \ n && i \in \{2, \ldots, n\}
\end{alignat*}
Um die erste Nebenbedingung zu analysieren, machen wir eine Fallunterscheidung nach dem Wert von $x_{ij}$:
````{prf:example}
TO DO
````
Es muss also $u_j$ um mindestens $1$ größer als $u_i$ sein, falls die Route $i-j$ in der Rundreise benutzt wird.

````{prf:example}
TO DO
````
Das Abzählen der Orte verhindert Subtouren. Beispielsweise würde sich im Falle einer Subtour $i-j-k-i$ die Ungleichungskette
````{prf:example}
TO DO
````
ergeben. 

#### Vergleich beider Modelle
Welches Modell ist besser? Das kann von der konreten Instanz abhängen. Wir lernen in den späteren Kapiteln einige Kriterien, um Modelle miteinander vergleichen zu können. Das erste Modell grenzt den Suchraum sehr gut ein, wir sagen es hat eine engere Relaxierung als das zweite Modell. Der Nachteil des ersten Modells ist die sehr große Anzahl an Nebenbedinungen.

### Tourenplanungsprobleme
Tourenplanungsprobleme heißen im Englischen *vehicle routing problems*.
Im Unterschied zum Problem des Handelsreisenden gibt es nicht nur einen Handelsreisenden, sondern $K$ verschiedene Fahrzeuge, die die $n$ Orte besuchen sollen. Wir gehen davon aus, dass alle Fahrzeuge im gleichen zentralen Lager starten. Eine Vorabaufteilung welches Fahrzeug welchen Kunden bedient gibt es nicht. Wir verzichten in diesem Abschnitt auf eine formale Problemdefinition. 

````{prf:example}
TO DO
````

Wir können dieses Problem durch das folgende gemischt-ganzzahlige Programm modellieren.

````{prf:example}
TO DO
````

#### Tourenplanungprobleme in der Praxis
Tourenplanungsprobleme sind eine äußert praxisrelevante Problemklasse. Anwendungen finden sich etwa im Bereich Lieferdienste oder Kundenservice. Über das oben beschriebene Grundproblem hinaus gibt es eine große Vielzahl an Modellierungsaspekten, die in der Praxis auftauchen. Beispiele sind etwa Kapazitätsbeschränkungen für  Fahrzeuge, Zeitfenster für  Kundenbesuche, uhrzeitabhängige Fahrzeiten, oder Restriktionen durch die Fahrt- und Ruhezeitenverordnung. Wegen der hohen Komplexität werden in der Praxis statt gemischt-ganzzahligen Programmen häufig auch heuristische Verfahren eingesetzt.


(subsub:lazyConstraints)=
## Lazy Constraints 
In Abschnitt {ref}`subsec:polyeder` ist beschrieben, dass der Raum der zulässigen Lösungen eines linearen Programms ein Polyeder ist, der in der Form
\begin{align*}
P=\{x \in \R^n \mid Ax \leq b\} = \left\{ x \mid \sum_{j=1}^na_{ij}x_j \leq b_i \text{ für } i = 1 \ldots m  \right\}
\end{align*}
ausgedrückt werden kann. Jede der $m$ Nebenbedingungen 
\begin{align*}
\sum_{j=1}^na_{ij}x_j \leq b_i
\end{align*}
verbietet also einen Halbraum von $\R^n$ für die Menge der zulässigen Lösungen. Wir fragen uns, ob immer alle Nebenbedingungen nötig sind, um eine optimale Lösung zu finden. 

````{prf:example}
TO DO
````

````{prf:definition} Bindende Nebenbedingung
Sei $P=\{x \in \R^n \mid Ax \leq b\}$ ein Polyeder und $\overline x=(\overline x_1, \overline x_2, \ldots, \overline x_n)^T \in P$. Dann heißt die Nebenbedingung 
$
\sum_{j=1}^na_{ij}x_j \leq b_i
$ *bindend* für $\overline x$, falls 
\begin{align*}
\sum_{j=1}^na_{ij}\overline x_j = b_i.
\end{align*}	
````

Eine Nebenbedingung ist also nur (lokal) einschränkend für einen Punkt $x$ in Optimierungsrichtung, falls Sie auch bindend ist.


Gemischt-ganzzahlige Programme werden typischerweise über Branch-And-Bound Verfahren gelöst. Es kann sein, dass viele Nebenbedingungen für keine der zulässigen Lösungen, die während des Branch-And-Bound Verfahrens besucht werden, bindend ist. 

````{prf:example}
TO DO
````

Leider kann man diese Nebenbedingungen nicht einfach komplett ignorieren, da vorab unbekannt ist, welche Nebenbedingungen für den Lösungsprozess nicht benötigt werden. 
Wie können wir trotzdem ausnutzen, wenn viele Nebenbedingungen nicht bindend werden?

Wir teilen die Menge $R$ der Nebenbedingungen auf in eine Menge von $R_{\initial}$ von "essentiellen" Nebenbedingungen, sowie eine Menge $R_{\lazy}$ von Nebenbedingungen, bei denen wir davon ausgehen, dass nur ein sehr kleiner Teil tatsächlich im Verlauf des Lösungsverfahrens bindend wird. Wir starten dann ein normales Branch-And-Bound Verfahren auf dem reduzierten Model, das nur die essentiellen Nebenbedingungen enthält. Wann immer eine zulässige Lösung $x$ gefunden wird, müssen wir überprüfen ob $x$  Nebenbedingungen aus $R_{\lazy}$ verletzt. Falls dies so ist, werden diese zum aktuellen Modell hinzugefügt. Danach wird mit dem  Branch-And-Bound Verfahren fortgefahren.
%
Insgesamt ergibt sich folgendes Vorgehen:

````{prf:algorithm} Branch-And-Bound Verfahren mit Lazy Constraints
**Eingabe:**
- Gemischt-ganzzahliges Programm $\ILP$ mit Nebenbedingungen $R=R_{\initial} \cup R_{\lazy}$

**Verfahren:**
- Starte das Branch-And-Bound Verfahren für $\ILP$ mit Nebenbedingungen $R_{\reduced} := R_{\initial}$.
  - Wann immer einer zulässige Lösung $x$ gefunden wurde
	  -	Prüfe ob $x$ eine Nebenbedingung in $R_{\lazy}$ verletzt
	  - Füge jede Nebenbedingung aus $R_{\lazy}$ die durch $x$ verletzt wird zu $R_{\reduced}$ hinzu
	  - Fahre mit dem Branch-And-Bound Verfahren fort
````

Um das Verfahren praktisch umzusetzen muss nicht unbedingt das Branch-And-Bound Verfahren selbst implementiert werden, sondern nur die Prüfroutine für die Verletzung der Nebenbedingungen. Viele Solver unterstützen dies über sogenannte *Callback-Funktionen*.


### Beispiel: Traveling Salesman Problem

Wir betrachten das Vorgehen am Beispiel der Formulierung nach Dantzig, Fulkerson und Johnson für das Traveling Salesman Problem (siehe Abschnitt {ref}`subsubsec:TSP`).		

\begin{alignat*}{5}
\min          & \quad  &   \sum_{i,j=1\ldots, n; i\not=j} & d_{ij}x_{ij}         & & \\[4mm]
\text{s.t. } & &  \sum_{j=1\ldots n, \ i \not=j}x_{ij} & =   1 && \quad\quad & & \forall i= 1, \ldots, n \\[2mm]
 & &  \sum_{i=1\ldots n, \ i \not=j}x_{ij} & =   1 && \quad\quad & & \forall j= 1, \ldots, n \\[2mm]
& & \sum_{i \in C'} \sum_{j \in C'}x_{ij} & \leq   |S|-1 && \quad\quad & & \forall C' \subset \{2, \ldots, n\}, \hspace{0.3cm} |C'| \geq 2 \\[2mm]
& & x_{ij} & \in  \B && && \forall i,j= 1, \ldots, n.
\end{alignat*}
Die ersten beiden Klassen von Nebenbedingungen stellen sicher, dass jeder Ort genau einmal besucht und wieder verlassen wird. Bei $n$ Orten gibt es je $n$ Nebenbedingungen von jeder Klasse. Mit Hinblick auf den Rechenaufwand ist dies unproblematisch. Wir betrachten beide Klassen als essentiell. Diese Nebenbedingungen bilden die Menge $R_{\initial}$.

Die dritte Klasse von Nebenbedingungen verhindert Subtouren. Diese Nebenbedingungen bilden die Menge $R_{\lazy}$. Es gibt eine Nebenbedingung pro möglicher Subtour. Dies sind insgesamt $2^{n-1}$ Nebenbedingungen. Selbst für relativ kleine Werte von $n$ sprengt dies die Möglichkeiten moderner Computer. Wir gehen davon aus, dass nur vergleichsweise wenige Subtouren im Lösungsprozess wirklich relevant werden. Dies Annahme legt die Nutzung als Lazy Constraint nahe.

```{figure} ./bilder/TSP-LoesungMitSubtouren.png
:name: TSP-LoesungMitSubtouren}
:height: 300px

```

Es bleibt noch die Frage zu klären, wie wir für eine gegebene Lösung $x$ effizient überprüfen, ob eine der Subtour-Eliminationsbedingungen verletzt wird. Falls alle $2^{n-1}$ Bedingungen erstellt und einzeln überprüft werden müssten, wird das Verfahren extrem langsam und nicht sinnvoll.

Für eine gegebene Lösung $x$ können wir den Nachfolger eines Ortes $k$ in der Tour oder Subtour bestimmen durch
\begin{align*}
\text{Nachfolger}(k)=l \text{ mit der Eigenschaft } x_{kl}=1
\end{align*}

````{prf:example}
TO DO
````

Wir können die Überprüfung effizient mit folgendem Algorithmus vornehmen:

````{prf:algorithm} Überprüfe auf Subtouren in Lösung $x$
:label: algo:findeSubtour

**Input**: Mögliche Lösung $x$

**Output**: Subtour falls existent

Startort=0

AktuellerOrt = Nachfolger(Startort)

Tour=[Startort, AktuellerOrt]

**while** *AktuellerOrt $\neq=$ Startort* **do**

  AktuellerOrt = Nachfolger(Startort)

  Füge AktuellerOrt an Tour an

**if** *Tour beinhaltet nicht alle Orte* **then**

  Subtour Tour gefunden
````

Der Algorithmus findet auf jeden Fall eine Subtour falls eine solche in $x$ existiert. Eine leicht abgewandelte Version des Vorgehens kann auch alle möglichen vorhandenen Subtouren finden.
````{prf:example}
TO DO
````

```{figure} ./bilder/TSP-lazy-constraints.png
:name: TSP-lazy-constraints
:height: 300px

Eine TSP-Instanz mit 50 Orten. Die Grafik zeigt alle 36 Zwischenlösungen, die bei einem Branch-And-Bound Verfahren mit Lazy-Constraints gefunden werden.
```


## Modellierung von stückweise linearen Funktionen

In der Realität sind Zielfunktionen nicht immer linear. Wir betrachten dazu folgendes Beispiel:

````{prf:example}
:label: fabrik

Eine Fabrik kann ein bestimmtes Produkt produzieren. Die Rüstkosten betragen 1000€ falls das Produkt überhaupt produziert wird. Die ersten 3000 produzierten Einheiten haben zusätzliche Produktionsstückkosten von 3€, die nächsten 2000 produzierten Einheiten haben zusätzliche Produktionsstückkosten von 2€, die nächsten 2000 produzierten Einheiten haben zusätzliche Produktionsstückkosten von 1€. Insgesamt hat die Fabrik einen maximale Kapazität von 7000 Stück.
````

```{figure} ./bilder/StueckweiseLineareFunktion.png
:name: StueckweiseLineareFunktion
:height: 300px

Stückweise lineare Kostenfunktion aus Beispiel {prf:ref}`fabrik`.
```

Es liegt also eine stückweise lineare Funktion vor.
Wie können wir die Produktionskosten $y$ abhängig von der Produktionsmenge $x$ modellieren? Wir betrachten zuerst den Produktionsbereich von 3000-5000 Stück:

````{prf:example}
TO DO
````

Wir führen also neue Variablen $\lambda_0, \ldots, \lambda_3 \geq 0$ ein.

````{prf:example}
TO DO
````

Wir betrachten einen konkreten Punkt $x \in [0,7000]$. 
Falls wir sicherstellen können, dass die $\lambda$-Werte abhängig vom konkreten Segment wie oben gewählt werden, können wir schreiben:

\begin{eqnarray*}
	x & = & \sum_{i=0}^k\lambda_is_i \\[2mm]
	y & = & \sum_{i=0}^k\lambda_if_i \\[2mm]
	1 & = & \sum_{i=0}^k\lambda_i 
\end{eqnarray*}

### SOS-Mengen
Wir müssen noch sicherstellen, dass die $\lambda$-Werte in der richtigen Form sind. Es müssen also 
- alle bis auf 2 der Variablen $\lambda_0, \ldots, \lambda_k$  den Wert $0$ annehmen,
- die beiden von Null unterschiedlichen Variablen direkt aufeinanderfolgen.
Eine solche Variablenmenge nennt man SOS-2 Menge. Der Vollständigkeit halber definieren wir zuerst SOS1-Mengen.

````{prf:definition} SOS1-Menge
Eine *Special Ordered Set vom Typ 1* ist eine Menge an Entscheidungsvariablen $\lambda_0, \ldots, \lambda_k$, für die gilt, dass in einer zulässigen Lösung höchstens eine Variable gleichzeitig ungleich $0$ ist.
````

````{prf:definition} SOS2-Menge]
Eine *Special Ordered Set vom Typ 2* ist eine geordnete Menge an Entscheidungsvariablen $\lambda_0, \ldots, \lambda_k$, für die gilt, dass in einer zulässigen Lösung höchstens zwei Variablen $\lambda_i, \lambda_{i+1}$ gleichzeitig ungleich $0$ sind und diese direkt aufeinanderfolgen.
````

Wie können wir garantieren, dass eine Menge $\lambda_0, \ldots, \lambda_k$ eine SOS2-Menge ist? Wir benötigen zusätzliche Binärvariablen $\delta_0, \ldots, \delta_{k-1}$. Wir modellieren wie folgt:
````{prf:example}
TO DO
````

Dies ergibt:
\begin{eqnarray*}
	\sum_{i=0}^{k-1} \delta_i & = & 1  \\[2mm]
	\lambda_1 & \leq & \delta_1 \\[2mm]
	\lambda_i & \leq & \delta_{i-1} + \delta_i \hspace{0.5cm} \text{ für } i=0, \ldots, k-1	\\[2mm]
	\lambda_k & \leq & \delta_{k-1} \\[2mm]
	\delta_i & \in & \B \text{ für } i=0, \ldots, k-1
\end{eqnarray*}

### Das fertige Modell
Gegeben ist eine stückweise lineare Funktion $f(x)$ mit Stützstellen $s_0, \ldots, s_k$ und deren Funktions\-werten $f_0, \ldots, f_k$. Wir möchten den Ausdruck $y=f(x)$ innerhalb eines linearen Programms modellieren. Wir nutzen dazu folgendes Modell

\begin{eqnarray*}
x & = & \sum_{i=0}^k\lambda_is_i \\[2mm]
y & = & \sum_{i=0}^k\lambda_if_i \\[2mm]
1 & = & \sum_{i=0}^k\lambda_i \\[3mm]	
\lambda_i & \geq & 0 \hspace{0.5cm} \text{ für } i=0, \ldots, k
\end{eqnarray*}

und den Bedingungen, dass $\lambda_0, \ldots, \lambda_k$ eine SOT2-Menge ist:

\begin{eqnarray*}
\sum_{i=0}^{k-1} \delta_i & = & 1  \\[2mm]
\lambda_1 & \leq & \delta_1 \\[2mm]
\lambda_i & \leq & \delta_{i-1} + \delta_i \hspace{0.5cm} \text{ für } i=0, \ldots, k-1	\\[2mm]
\lambda_k & \leq & \delta_{k-1} \\[2mm]
\delta_i & \in & \B \text{ für } i=0, \ldots, k-1
\end{eqnarray*}

````{prf:example}
TO DO
````

### Approximation von beliebigen Funktionen als stückweise lineare Funktion
In der Praxis sind häufig nichtlineare kontinuierliche Funktionen gegeben, die nicht stückweise linear sind.
```{figure} ./bilder/NichtlineareFunktionFuerApproximation.png
:name: NichtlineareFunktionFuerApproximation
:height: 300px

Beispiel einer nichtlinearen Funktion.
```

Wir können solche Funktionen approximativ modellieren, indem wir Stützstellen einfügen und die Funktion zwischen den Stützstellen als stückweise linear ansehen. Je mehr Stützstellen benutzt werden, desto genauer kann der echte Funktionsverlauf nachmodelliert werden. Allerdings steigt mit genauerer Modellierung der Speicherbedarf und wahrscheinlich auch die Komplexität des resultierenden gemischt-ganzzahligen linearen Programms.

 -->
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="04_Speicherproblem_rollierend.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">zurück</p>
        <p class="prev-next-title"><span class="section-number">4.5. </span>Anwendung: Energiespeicherproblem mit rollierendem Zeitfenster</p>
      </div>
    </a>
    <a class="right-next"
       href="06_Multivariate_Analysis.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">weiter</p>
        <p class="prev-next-title"><span class="section-number">6. </span>Funktionen und Ableitungen</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Inhalt
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#marktubersicht-milp-solver">5.1. Marktübersicht MILP-Solver</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ubersicht">5.1.1. Übersicht</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#benchmarks">5.1.2. Benchmarks</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#modellierungsumgebungen">5.1.3. Modellierungsumgebungen</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#moglichkeiten-zur-beschleunigung-des-losungsverfahrens">5.2. Möglichkeiten zur Beschleunigung des Lösungsverfahrens</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#allgemeine-kriterien-fur-die-bewertung-eines-modells">5.2.1. Allgemeine Kriterien für die Bewertung eines Modells</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#modellgrosze">Modellgröße</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#laufzeit-der-modellerzeugung">Laufzeit der Modellerzeugung</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#numerische-stabilitat">Numerische Stabilität</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#scharfe-der-lp-relaxierung">Schärfe der LP-Relaxierung</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parametereinstellungen-des-losers">5.2.2. Parametereinstellungen des Lösers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#heuristiken-und-dekompositionen">5.2.3. Heuristiken und Dekompositionen</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#zeitfenster">5.2.4. Zeitfenster</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#rollierende-planung">Rollierende Planung</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#partitionierung-der-zeitachse-in-intervalle">Partitionierung der Zeitachse in Intervalle</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#angrenzende-intervalle-mit-vorschauperiode">Angrenzende Intervalle mit Vorschauperiode</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#interpretation-der-solver-ausgaben">5.3. Interpretation der Solver-Ausgaben</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
Durch Dennis Janka
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>