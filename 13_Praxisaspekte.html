
<!DOCTYPE html>

<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>13. Praxisaspekte beim Lösen von gemischt-ganzzahligen Programmen &#8212; Optimierungsverfahren, Modellierung und Simulation (DSCB410)</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="_static/translations.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"N": "\\mathbb{N}", "R": "\\mathbb{R}", "B": "\\mathbb{B}", "I": "\\mathbb{I}", "NN": "\\mathbb{N}", "RR": "\\mathbb{R}", "BB": "\\mathbb{B}", "norm": ["\\left\\lVert#1 \\right\\rVert", 1], "floor": ["\\lfloor#1\\rfloor", 1], "bmat": ["\\begin{pmatrix}"], "emat": ["\\end{pmatrix}"], "bmats": ["\\left(\\begin{smallmatrix}"], "emats": ["\\end{smallmatrix}\\right)"], "scikit": ["\\texttt{scikit-learn}"], "derv": ["\\frac{\\partial #1}{\\partial #2}", 2], "dervquad": ["\\frac{\\partial^2 #1}{\\partial #2^2}", 2], "dervzwei": ["\\frac{\\partial^2 #1}{\\partial {#2} \\partial {#3}}", 3], "v": ["\\mathbf{#1}", 1], "m": ["\\mathbf{#1}", 1], "argmin": ["\\underset{#1}{\\operatorname{arg\\!min}}", 1], "hyper": ["{\\color{Bittersweet}{#1}}", 1], "initial": "\\DeclareMathOperator{\\initial}{initial}", "reduced": "\\DeclareMathOperator{\\reduced}{reduced}", "lazy": "\\DeclareMathOperator{\\lazy}{lazy}", "ILP": "\\DeclareMathOperator{\\ILP}{ILP}"}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Stichwortverzeichnis" href="genindex.html" />
    <link rel="search" title="Suche" href="search.html" />
    <link rel="prev" title="12. Ablaufplanung" href="12_Ablaufplanung.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="de">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/HKA_IWI_Bildmarke-h_RGB.svg" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Optimierungsverfahren, Modellierung und Simulation (DSCB410)</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="00_Ueberblick.html">
                    Überblick
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Nichtlineare Optimierung
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="01_Multivariate_Analysis.html">
   1. Funktionen und Ableitungen
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="02_Theoretische_Grundlagen.html">
   2. Grundlagen der nichtlinearen Optimierung
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="03_Gradientenverfahren.html">
   3. Gradientenverfahren
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="04_Verfahren_zweiter_Ordnung.html">
   4. Verfahren zweiter Ordnung
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="05_Automatische_Differentiation.html">
   5. Automatische Differentiation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="06_Gradientenverfahren_ML.html">
   6. Gradientenverfahren im maschinellen Lernen
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="07_Grundlagen_beschraenkte_Optimierung.html">
   7. Grundlagen der beschränkten Optimierung
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Lineare Optimierung
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="08_MILP.html">
   8. Gemischt-ganzzahlige lineare Programmierung
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="09_Standardprobleme.html">
   9. Einige Standardprobleme
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="10_Modellierungstechniken.html">
   10. Fortgeschrittene Modellierungstechniken
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="11_Zeitdiskrete_Modelle.html">
   11. Zeitdiskrete Modelle
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="12_Ablaufplanung.html">
   12. Ablaufplanung
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   13. Praxisaspekte beim Lösen von gemischt-ganzzahligen Programmen
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="_sources/13_Praxisaspekte.md"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.md</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#losungsverfahren">
   13.1. Lösungsverfahren
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#preprocessing">
     13.1.1. Preprocessing
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#branch-and-bound">
     13.1.2. Branch and bound
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#schnittebenen">
     13.1.3. Schnittebenen
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#marktubersicht-milp-solver">
   13.2. Marktübersicht MILP-Solver
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ubersicht">
     13.2.1. Übersicht
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#benchmarks">
     13.2.2. Benchmarks
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#modellierungsumgebungen">
     13.2.3. Modellierungsumgebungen
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#moglichkeiten-zur-beschleunigung-des-losungsverfahrens">
   13.3. Möglichkeiten zur Beschleunigung des Lösungsverfahrens
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#allgemeine-kriterien-fur-die-bewertung-eines-modells">
     13.3.1. Allgemeine Kriterien für die Bewertung eines Modells
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#modellgrosze">
       13.3.1.1. Modellgröße
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#laufzeit-der-modellerzeugung">
       13.3.1.2. Laufzeit der Modellerzeugung
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#numerische-stabilitat">
       13.3.1.3. Numerische Stabilität
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#scharfe-der-lp-relaxierung">
       13.3.1.4. Schärfe der LP-Relaxierung
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#parametereinstellungen-des-losers">
     13.3.2. Parametereinstellungen des Lösers
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#heuristiken-und-dekompositionen">
     13.3.3. Heuristiken und Dekompositionen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#zeitfenster">
     13.3.4. Zeitfenster
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#rollierende-planung">
       13.3.4.1. Rollierende Planung
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#partitionierung-der-zeitachse-in-intervalle">
       13.3.4.2. Partitionierung der Zeitachse in Intervalle
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#angrenzende-intervalle-mit-vorschauperiode">
       13.3.4.3. Angrenzende Intervalle mit Vorschauperiode
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#lazy-constraints">
     13.3.5. Lazy Constraints
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#beispiel-traveling-salesman-problem">
       13.3.5.1. Beispiel: Traveling Salesman Problem
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#interpretation-der-solver-ausgaben">
   13.4. Interpretation der Solver-Ausgaben
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Praxisaspekte beim Lösen von gemischt-ganzzahligen Programmen</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#losungsverfahren">
   13.1. Lösungsverfahren
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#preprocessing">
     13.1.1. Preprocessing
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#branch-and-bound">
     13.1.2. Branch and bound
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#schnittebenen">
     13.1.3. Schnittebenen
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#marktubersicht-milp-solver">
   13.2. Marktübersicht MILP-Solver
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ubersicht">
     13.2.1. Übersicht
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#benchmarks">
     13.2.2. Benchmarks
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#modellierungsumgebungen">
     13.2.3. Modellierungsumgebungen
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#moglichkeiten-zur-beschleunigung-des-losungsverfahrens">
   13.3. Möglichkeiten zur Beschleunigung des Lösungsverfahrens
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#allgemeine-kriterien-fur-die-bewertung-eines-modells">
     13.3.1. Allgemeine Kriterien für die Bewertung eines Modells
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#modellgrosze">
       13.3.1.1. Modellgröße
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#laufzeit-der-modellerzeugung">
       13.3.1.2. Laufzeit der Modellerzeugung
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#numerische-stabilitat">
       13.3.1.3. Numerische Stabilität
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#scharfe-der-lp-relaxierung">
       13.3.1.4. Schärfe der LP-Relaxierung
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#parametereinstellungen-des-losers">
     13.3.2. Parametereinstellungen des Lösers
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#heuristiken-und-dekompositionen">
     13.3.3. Heuristiken und Dekompositionen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#zeitfenster">
     13.3.4. Zeitfenster
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#rollierende-planung">
       13.3.4.1. Rollierende Planung
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#partitionierung-der-zeitachse-in-intervalle">
       13.3.4.2. Partitionierung der Zeitachse in Intervalle
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#angrenzende-intervalle-mit-vorschauperiode">
       13.3.4.3. Angrenzende Intervalle mit Vorschauperiode
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#lazy-constraints">
     13.3.5. Lazy Constraints
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#beispiel-traveling-salesman-problem">
       13.3.5.1. Beispiel: Traveling Salesman Problem
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#interpretation-der-solver-ausgaben">
   13.4. Interpretation der Solver-Ausgaben
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="praxisaspekte-beim-losen-von-gemischt-ganzzahligen-programmen">
<h1><span class="section-number">13. </span>Praxisaspekte beim Lösen von gemischt-ganzzahligen Programmen<a class="headerlink" href="#praxisaspekte-beim-losen-von-gemischt-ganzzahligen-programmen" title="Link zu dieser Überschrift">#</a></h1>
<section id="losungsverfahren">
<h2><span class="section-number">13.1. </span>Lösungsverfahren<a class="headerlink" href="#losungsverfahren" title="Link zu dieser Überschrift">#</a></h2>
<section id="preprocessing">
<h3><span class="section-number">13.1.1. </span>Preprocessing<a class="headerlink" href="#preprocessing" title="Link zu dieser Überschrift">#</a></h3>
<p>Leistungsstarke Löser setzen <em>Presolve-Routinen</em> ein.
Diese stellen einen  Vorberechnungsschritt dar, der das Ziel hat, das zu lösende Problem zu verkleinern, sowie zu vereinfachen.
Der ursprüngliche zulässige Bereich soll dabei voll rekonstruierbar bleiben.</p>
<p>Eine detaillierte Beschreibung solcher Presolve-Routinen findet sich in <em>Achterberg, Bixby, Gu, Rothberg, Weninger: Presolve Reductions in Mixed Integer Programming, INFORMS Journal On Computing, 2019</em>.</p>
</section>
<section id="branch-and-bound">
<h3><span class="section-number">13.1.2. </span>Branch and bound<a class="headerlink" href="#branch-and-bound" title="Link zu dieser Überschrift">#</a></h3>
<p>Es gibt verschiedene Verfahren, um gemischt-ganzzahlige Programme zu lösen.
Der Kern aktueller Softwaresysteme sind Branch-And-Bound Verfahren.
Hierbei wird zuerst das relaxierte Problem gelöst (die sogenannte Root-Relaxation).
Danach wird nach ganzzahligen Variablen, für die eine fraktionale (nicht ganzzahlige) Lösung vorliegt verzweigt.
Eine gute Einführung in Branch-And-Bound Verfahren für gemischt-ganzzahlige Programme findet sich in <a class="reference external" href="http://web.mit.edu/15.053/www/AMP.htm">Bradley, Hax, Magnanti: Applied Mathematical Programming, Addison-Wesley, 1977</a>.</p>
<p>Dieser algorithmische Kern wird häufig durch zahlreiche heuristische Zusätze erweitert.
Beispielsweise werden Heuristiken benutzt, um schnell zulässige Lösungen zu finden oder gute Branching-Regeln zu lernen.
Bedingt durch das Branch-And-Bound Verfahren selbst, sowie die Zusatz-heuristiken ist eine genaue Vorhersage der nötigen Rechenzeit normalerweise nicht möglich.
Es gibt allerdings Anhaltspunkte, von denen einige in Abschnitt <a class="reference internal" href="#subsubsec-kriterienbewertung"><span class="std std-ref">Allgemeine Kriterien für die Bewertung eines Modells</span></a> geschildert werden.</p>
</section>
<section id="schnittebenen">
<h3><span class="section-number">13.1.3. </span>Schnittebenen<a class="headerlink" href="#schnittebenen" title="Link zu dieser Überschrift">#</a></h3>
<p>Eine Möglichkeit, um den Lösungsprozess zu beschleunigen, ist das Zufügen von zusätzlichen Nebenbedingungen, die den zulässigen Lösungsraum nicht verändern, aber in einer schärferen Relaxierung resultieren. Solche Nebenbedinungen heißen <em>Schnittebenen</em> (eng: cutting planes).
Bei tiefer Problemkenntnis können Schnittebenen manuell zugefügt werden.
Einige Löser erzeugen und nutzen automatisiert Schnittebenen.</p>
</section>
</section>
<section id="marktubersicht-milp-solver">
<h2><span class="section-number">13.2. </span>Marktübersicht MILP-Solver<a class="headerlink" href="#marktubersicht-milp-solver" title="Link zu dieser Überschrift">#</a></h2>
<p>Es gibt eine größere Anzahl an brauchbaren kommerziellen und nichtkommerziellen Softwaretools zum Lösen von gemischt-ganzzahligen Programmen.
Die kommerziellen Anwendungen weisen hierbei typischerweise deutlich höhere Lösungsgeschwindigkeiten auf. Dem Dozenten ist kein aktueller unabhängiger umfassender wissenschaftlicher Vergleich zwischen den einzelnen Software-lösungen bekannt.</p>
<section id="ubersicht">
<h3><span class="section-number">13.2.1. </span>Übersicht<a class="headerlink" href="#ubersicht" title="Link zu dieser Überschrift">#</a></h3>
<p>Bekannte kommerzielle Anwendungen sind etwa CLEX, GUROBI und XPRESS, bekannte Open-Source Lösungen sind etwa CBC, LPSolve und SCIP.
Eine nicht qualitätsgesicherte, aber zum Stand 01.04.2020 brauchbare Auflistung aktueller Softwaretools findet sich in der Wikipedia unter
<a class="reference external" href="https://en.wikipedia.org/wiki/List_of_optimization_software">List of Optimization Software</a>.</p>
</section>
<section id="benchmarks">
<h3><span class="section-number">13.2.2. </span>Benchmarks<a class="headerlink" href="#benchmarks" title="Link zu dieser Überschrift">#</a></h3>
<p>Zum Stand vom 01.04.2020 erlaubt der
<a class="reference external" href="https://neos-server.org/neos/">NEOS Server</a>
Probleme kostenlos durch verschiedenene Solver zu lösen.</p>
<p>Ein etwas älteres Benchmark der Solver CPLEX, GUROBI und XPRESS findet sich in \emph{Josef Jablonsky: Benchmarks for current linear and mixed integer optimization solvers, Acta Universitatis Agriculturae et Silviculturae Mendelianae Brunensis, 2015}.</p>
<p>Weitere Benchmarks werden regelmäßig unter
<a class="reference external" href="http://plato.asu.edu/bench.html">http://plato.asu.edu/bench.html</a> veröffentlicht.
Diese enthalten seit 2018 keine Resultate für CPLEX, Gurobi und XPRESS (siehe \emph{Hans Mittelmann: Benchmarking Optimization Software - a (Hi)Story, SN Operations Research Forum, 2020}).</p>
<p>Der folgende Auszug stammt aus den Vortragsfolien zu
<em>Hans Mittelmann, Latest Benchmarks of Optimization Software, INFORMS Annual Meeting, Houston, 2017</em>.</p>
<figure class="align-default" id="benchmarkmittelmann2017">
<a class="reference internal image-reference" href="_images/BenchmarkMittelmann2017.png"><img alt="_images/BenchmarkMittelmann2017.png" src="_images/BenchmarkMittelmann2017.png" style="height: 300px;" /></a>
</figure>
<figure class="align-default" id="benchmarkmittelmann2017-2">
<a class="reference internal image-reference" href="_images/BenchmarkMittelmann2017_2.png"><img alt="_images/BenchmarkMittelmann2017_2.png" src="_images/BenchmarkMittelmann2017_2.png" style="height: 300px;" /></a>
</figure>
<figure class="align-default" id="benchmarkmittelmann2017-3">
<a class="reference internal image-reference" href="_images/BenchmarkMittelmann2017_3.png"><img alt="_images/BenchmarkMittelmann2017_3.png" src="_images/BenchmarkMittelmann2017_3.png" style="height: 300px;" /></a>
</figure>
</section>
<section id="modellierungsumgebungen">
<h3><span class="section-number">13.2.3. </span>Modellierungsumgebungen<a class="headerlink" href="#modellierungsumgebungen" title="Link zu dieser Überschrift">#</a></h3>
<p>Zusätzlich gibt es Modellierungsumgebungen, die es ermöglichen, Modelle unabhängig von einem konkreten Löser zu erzeugen. Dies erlaubt ein einfaches Austauschen des konkreten Lösers.
Unter Umständen können diese Umgebungen nicht auf alle Eigenheiten oder Features eines speziellen Lösers zugreifen.
Je nach Kombination aus Solver und Modellierungsumgebung erlaubt die Umgebung auch eine komfortablere Erstellung des Modells.</p>
<p>Bekannte solche Frameworks sind etwa AIMMS, AMPL, GAMS, JuMP, PuLP, Pyomo.</p>
</section>
</section>
<section id="moglichkeiten-zur-beschleunigung-des-losungsverfahrens">
<h2><span class="section-number">13.3. </span>Möglichkeiten zur Beschleunigung des Lösungsverfahrens<a class="headerlink" href="#moglichkeiten-zur-beschleunigung-des-losungsverfahrens" title="Link zu dieser Überschrift">#</a></h2>
<p>Ein kritischer Aspekt bei der Arbeit mit gemischt-ganzzahligen Programmen ist die Rechenzeit die zur Lösung eines Modells benötigt wird.
Das effiziente Lösen von gemischt-ganzzahligen Programmen ist ein weites Forschungsfeld, das eine reichhaltige und tiefgehende theoretische Basis entwickelt hat.</p>
<p>Moderne Löser arbeiten typischerweise mit einem Branch-And-Bound Verfahren, dass um eine eine große Anzahl an heuristischen Methoden zur Laufzeitverbesserung erweitert wurde. Zusätzlich ist der Einsatz einer Presolve-Methode Standard.
Die konkret vorliegende Hardwarekonfiguration hat einen zusätzlichen Einfluss auf die Lösungsgeschwindigkeit.
Aus diesem Grund ist das Laufzeitverhalten für ein bestimmtes Modell nicht komplett vorhersagbar.
Im Folgenden skizzieren wir einige allgemeine Gedanken und Ansatzpunkte, mit denen die Rechenzeit in der Praxis verbessert werden kann.</p>
<section id="allgemeine-kriterien-fur-die-bewertung-eines-modells">
<span id="subsubsec-kriterienbewertung"></span><h3><span class="section-number">13.3.1. </span>Allgemeine Kriterien für die Bewertung eines Modells<a class="headerlink" href="#allgemeine-kriterien-fur-die-bewertung-eines-modells" title="Link zu dieser Überschrift">#</a></h3>
<section id="modellgrosze">
<h4><span class="section-number">13.3.1.1. </span>Modellgröße<a class="headerlink" href="#modellgrosze" title="Link zu dieser Überschrift">#</a></h4>
<p>Ein erstes wichtiges Kriterium für die Bewertung eines Modells ist seine Größe.
Diese kann in der Anzahl der Variablen gemessen werden.</p>
<p>Wichtig ist eine Unterscheidung in kontinuierliche und ganzzahlige Variablen.
Kontinuierliche Variablen können effizient durch das Simplex-Verfahren bestimmt werden.
Diskrete Variablen hingegen verursachen typischerweise den Hauptrechenaufwand, da sie durch ein aufwendigeres Branch-And-Bound Verfahren bestimmt werden müssen.</p>
<p>Bei manchen Modellen macht es zusätzlich Sinn, die Anzahl der Nebenbedingungen zu betrachten.</p>
</section>
<section id="laufzeit-der-modellerzeugung">
<h4><span class="section-number">13.3.1.2. </span>Laufzeit der Modellerzeugung<a class="headerlink" href="#laufzeit-der-modellerzeugung" title="Link zu dieser Überschrift">#</a></h4>
<p>Der Grund für einen langsamen Gesamtlösungsprozess muss nicht unbedingt in der Laufzeit des mathematischen Lösers selbst liegen.
Bei ineffizienter Programmierung oder langsamer Datenbereitstellung kann der Hauptteil der Rechenzeit durch das Erstellen des Modells anstatt durch das Lösen verursacht werden.</p>
<p>Als professionelle Diagnosetools stehen für die meisten Programmiersprachen sogenannte <em>Profiler</em> bereit, die die Programmlaufzeit nach Einzelroutinen aufschlüsseln können.  Häufig genügt zur Diagnose allerdings auch ein Lauf des Programmcodes, bei dem der finale Aufruf des Lösers auskommentiert ist.</p>
</section>
<section id="numerische-stabilitat">
<h4><span class="section-number">13.3.1.3. </span>Numerische Stabilität<a class="headerlink" href="#numerische-stabilitat" title="Link zu dieser Überschrift">#</a></h4>
<p>Mathematische Löser für gemischt-ganzzahlige Programme arbeiten nicht mit exakten Zahlen, sondern nutzen die in Computern übliche Fließkommaarithmetik mit beschränkter Genauigkeit. Häufig stellt dies kein Problem dar.</p>
<p>Wenn die Größenordnungen der Eingabewerte stark unterschiedlich sind, kann es zu numerischen Problemen kommen.
Ein Vergleich von kleinstem und größtem vorkommenden Eingabewert gibt einen erstes Indiz dafür, ob das Problem numerisch schwierig zu lösen ist.</p>
</section>
<section id="scharfe-der-lp-relaxierung">
<h4><span class="section-number">13.3.1.4. </span>Schärfe der LP-Relaxierung<a class="headerlink" href="#scharfe-der-lp-relaxierung" title="Link zu dieser Überschrift">#</a></h4>
<p>Wir haben in Abschnitt <a class="reference internal" href="10_Modellierungstechniken.html#subsec-disjunctiveprogramming"><span class="std std-ref">Disjunktive Programmierung</span></a> gesehen, dass Modelle die den gleichen zulässigen Lösungsraum beschreiben, sich trotzdem durch die Schärfe ihrer LP-Relaxierung unterscheiden können.
Es gibt tiefgehende Theorie, um den zu einem linearen Programm zugehörigen Lösungspolyeder zu beschreiben.</p>
<p>Einen guten ersten Eindruck zur Güte der LP-Relaxierung kann man durch die <em>Ganzzahligkeitslücke</em> (engl: integrality gap) gewinnen.</p>
<div class="proof definition admonition" id="definition-0">
<p class="admonition-title"><span class="caption-number">Definition 13.1 </span> (Ganzzahligkeitslücke)</p>
<section class="definition-content" id="proof-content">
<p>Gegeben ist ein gemischt-ganzzahliges Programm MILP mit optimaler Lösung <span class="math notranslate nohighlight">\(f^*\)</span> und das zu MILP relaxierte Problem LP mit optimaler Lösung <span class="math notranslate nohighlight">\(f^*_{rel}\)</span>. Die Ganzzahligkeitslücke von MILP ist
<span class="math notranslate nohighlight">\({f^*}/{f^*_{rel}}\)</span> falls MILP ein Minimierungsproblem ist und <span class="math notranslate nohighlight">\({f^*_{rel}}/{f^*}\)</span> sonst.</p>
</section>
</div><p>Die Ganzzahligkeitslücke ist mindestens <span class="math notranslate nohighlight">\(1\)</span>. Kleinere Werte sind im Allgemeinen besser.</p>
<div class="proof example admonition" id="example-1">
<p class="admonition-title"><span class="caption-number">Example 13.1 </span></p>
<section class="example-content" id="proof-content">
<p>TO DO</p>
</section>
</div></section>
</section>
<section id="parametereinstellungen-des-losers">
<h3><span class="section-number">13.3.2. </span>Parametereinstellungen des Lösers<a class="headerlink" href="#parametereinstellungen-des-losers" title="Link zu dieser Überschrift">#</a></h3>
<p>Die heuristischen Vorgehen innerhalb moderner Löser arbeiten mit guten Voreinstellungen, die auf konkrete Instanzen ohne Programmierarbeit angepasst werden können. Die Einstellungs-möglichkeiten variieren für verschiedene Löser. Beispielhaft folgt eine Übersicht für den kommerziellen Solver Gurobi (Quelle: <a class="reference external" href="https://www.gurobi.com/documentation/9.0/refman/mip_models.html">www.gurobi.com</a>, abgerufen am  31.03.2020).</p>
<figure class="align-default" id="gurobi-parameters-chunk1">
<a class="reference internal image-reference" href="_images/Gurobi_parameters_chunk1.png"><img alt="_images/Gurobi_parameters_chunk1.png" src="_images/Gurobi_parameters_chunk1.png" style="height: 300px;" /></a>
</figure>
<figure class="align-default" id="gurobi-parameters-chunk2">
<a class="reference internal image-reference" href="_images/Gurobi_parameters_chunk2.png"><img alt="_images/Gurobi_parameters_chunk2.png" src="_images/Gurobi_parameters_chunk2.png" style="height: 300px;" /></a>
</figure>
</section>
<section id="heuristiken-und-dekompositionen">
<h3><span class="section-number">13.3.3. </span>Heuristiken und Dekompositionen<a class="headerlink" href="#heuristiken-und-dekompositionen" title="Link zu dieser Überschrift">#</a></h3>
<p>Ist es nicht möglich, ein Modell in akzeptabler Zeit optimal zu lösen, liegt eine mögliche Strategie im Einsatz von Heuristiken. Man nimmt dann davon Abstand, beweisbar optimale Lösungen zu finden, sondern hofft auf ausreichend gute Ergebnisse.</p>
<p>Ein häufiges heuristisches Vorgehen in Zusammenhang mit gemischt-ganzzahligen Programmen ist das der <em>Problemdekomposition</em>.
Dabei werden nicht mehr alle Entscheidungsvariablen “gleichzeitig” bestimmt.
Stattdessen wird das Problem in verschiedene Ebenen unterteilt, die nacheinander gelöst werden.
Jede Ebene legt eine bestimme Menge an Entscheidungsvariablen fest, die von den unterliegenden Ebenen nicht mehr revidiert werden können.</p>
<p>Wir betrachten dies am Beispiel des Vehicle-Routing Problems.
Sogenannte Cluster-First Route-Second Ansätze entscheiden zuerst, welche Orte zu Touren zusammengefasst werden (erste Ebene).
Danach werden die Touren einzeln as Traveling Salesman Instanzen gelöst (zweite Ebene).</p>
<div class="proof example admonition" id="example-2">
<p class="admonition-title"><span class="caption-number">Example 13.2 </span></p>
<section class="example-content" id="proof-content">
<p>TO DO</p>
</section>
</div></section>
<section id="zeitfenster">
<h3><span class="section-number">13.3.4. </span>Zeitfenster<a class="headerlink" href="#zeitfenster" title="Link zu dieser Überschrift">#</a></h3>
<p>Ein spezielles Dekompositionsverfahren für zeitexpandierte Modelle sind die sogenannten <em>Zeitfenster</em>.
Diese heißen im Engischen <em>time windows</em>.
Hierbei wird die Zeitachse in mehrere Intervalle zerlegt, die nacheinander gelöst werden.
Dabei baut jedes Zeitfenster auf der Situation des vorhergehenden Zeitfensters auf.
Entscheidungen, die vor Beginn des aktuellen Zeitfensters liegen, sind fest und können nicht mehr geändert werden.
Die Situation nach dem aktuellen Zeitfenster wird für dieses nicht berücksichtigt, sondern erst in den folgenden Zeitfenstern.</p>
<p><em>Wichtig:</em> Der Einsatz von Zeitfenstern ist eine Heuristik. Es kann nicht  garantiert werden, dass die optimale Lösung für das ursprüngliche Problem gefunden wird.</p>
<section id="rollierende-planung">
<h4><span class="section-number">13.3.4.1. </span>Rollierende Planung<a class="headerlink" href="#rollierende-planung" title="Link zu dieser Überschrift">#</a></h4>
<p>Es gibt verschiedene Möglichkeiten, Zeitfenster zu realisieren. Eine Möglichkeit sind <em>rollierende Fenster</em>, bei denen das Fenster in jedem Schritt nur um wenige Zeitschritte nach vorne bewegt wird.</p>
<div class="proof example admonition" id="example-3">
<p class="admonition-title"><span class="caption-number">Example 13.3 </span></p>
<section class="example-content" id="proof-content">
<p>TO DO</p>
</section>
</div></section>
<section id="partitionierung-der-zeitachse-in-intervalle">
<h4><span class="section-number">13.3.4.2. </span>Partitionierung der Zeitachse in Intervalle<a class="headerlink" href="#partitionierung-der-zeitachse-in-intervalle" title="Link zu dieser Überschrift">#</a></h4>
<p>Eine Möglichkeit, um weniger Zeitfenster lösen zu müssen ist, die Zeitachse in disjunkte, aneinander angrenzende Intervalle aufzuteilen.</p>
<div class="proof example admonition" id="example-4">
<p class="admonition-title"><span class="caption-number">Example 13.4 </span></p>
<section class="example-content" id="proof-content">
<p>TO DO</p>
</section>
</div><p>Häufig sind die Ergebnisse dieser Methode nicht zufriedenstellend, da an den Intervallgrenzen unerwünschte Effekte auftreten.
Auf der nächsten Seite findet sich ein solcher Zeitfenster-Ansatz für das Speicheroptimierungsproblem aus Kapitel <a class="reference internal" href="11_Zeitdiskrete_Modelle.html#sec-zeitdiskret"><span class="std std-ref">Zeitdiskrete Modelle</span></a>. Wir sehen, dass zu Ende jedes Zeitfensters, die Batterie komplett geleert wird.
Dies macht für das konkrete Zeitfenster Sinn, da so Kosten innerhalb des Fensters gespart werden.
Es führt allerdings typischerweise zu suboptimalen Lösungen für das Gesamtproblem.</p>
</section>
<section id="angrenzende-intervalle-mit-vorschauperiode">
<h4><span class="section-number">13.3.4.3. </span>Angrenzende Intervalle mit Vorschauperiode<a class="headerlink" href="#angrenzende-intervalle-mit-vorschauperiode" title="Link zu dieser Überschrift">#</a></h4>
<p>Eine Lösung für das vorangegangene Problem ist der zusätzliche Einsatz einer Vorschauperiode.
Hierbei enthält jedes Zeitfenster einen zusätzlichen Zeitraum, der an das Ende des Fensters angehängt wird.
Das Optimierungsproblem umfasst das eigentliche Intervall, zusammen mit der Vorschauperiode und optimiert beides.
Es werden nur die Entscheidungen für das eigentliche Intervall festgehalten.
Die Entscheidungen der Vorschauperiode werden verworfen.
Die Vorschauperiode ist dann Teil des nächsten Zeitfensters. Ein Beispiel findet sich hier: <a class="reference internal" href="#batteriezeitfenster-ohnelookahead"><span class="std std-ref">Zeitfensteransatz für das Problem aus Kapitel sec:zeitdiskret ohne Vorschauperiode.</span></a>.</p>
<div class="proof example admonition" id="example-5">
<p class="admonition-title"><span class="caption-number">Example 13.5 </span></p>
<section class="example-content" id="proof-content">
<p>TO DO</p>
</section>
</div><figure class="align-default" id="batteriezeitfenster-ohnelookahead">
<a class="reference internal image-reference" href="_images/BatterieZeitfenster_OhneLookAhead.png"><img alt="_images/BatterieZeitfenster_OhneLookAhead.png" src="_images/BatterieZeitfenster_OhneLookAhead.png" style="height: 300px;" /></a>
<figcaption>
<p><span class="caption-number">Abb. 13.1 </span><span class="caption-text">Zeitfensteransatz für das Problem aus Kapitel <a class="reference internal" href="11_Zeitdiskrete_Modelle.html#sec-zeitdiskret"><span class="std std-ref">Zeitdiskrete Modelle</span></a> ohne Vorschauperiode.</span><a class="headerlink" href="#batteriezeitfenster-ohnelookahead" title="Link zu diesem Bild">#</a></p>
</figcaption>
</figure>
<figure class="align-default" id="batteriezeitfenster-mitlookahead">
<a class="reference internal image-reference" href="_images/BatterieZeitfenster_MitLookAhead.png"><img alt="_images/BatterieZeitfenster_MitLookAhead.png" src="_images/BatterieZeitfenster_MitLookAhead.png" style="height: 300px;" /></a>
<figcaption>
<p><span class="caption-number">Abb. 13.2 </span><span class="caption-text">Zeitfensteransatz für das Problem aus Kapitel <a class="reference internal" href="11_Zeitdiskrete_Modelle.html#sec-zeitdiskret"><span class="std std-ref">Zeitdiskrete Modelle</span></a> mit Vorschauperiode.</span><a class="headerlink" href="#batteriezeitfenster-mitlookahead" title="Link zu diesem Bild">#</a></p>
</figcaption>
</figure>
<p>Rollierende Planung für das Beispielmodel aus Kapitel <a class="reference internal" href="11_Zeitdiskrete_Modelle.html#sec-zeitdiskret"><span class="std std-ref">Zeitdiskrete Modelle</span></a>.</p>
<div class="proof example admonition" id="example-6">
<p class="admonition-title"><span class="caption-number">Example 13.6 </span></p>
<section class="example-content" id="proof-content">
<p>TO DO</p>
</section>
</div></section>
</section>
<section id="lazy-constraints">
<span id="subsub-lazyconstraints"></span><h3><span class="section-number">13.3.5. </span>Lazy Constraints<a class="headerlink" href="#lazy-constraints" title="Link zu dieser Überschrift">#</a></h3>
<p>In Abschnitt <a class="reference internal" href="08_MILP.html#subsec-polyeder"><span class="std std-ref">Der Polyeder der zulässigen Lösungen</span></a> ist beschrieben, dass der Raum der zulässigen Lösungen eines linearen Programms ein Polyeder ist, der in der Form</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
P=\{x \in \RR^n \mid Ax \leq b\} = \left\{ x \mid \sum_{j=1}^na_{ij}x_j \leq b_i \text{ für } i = 1 \ldots m  \right\}
\end{align*}\]</div>
<p>ausgedrückt werden kann. Jede der <span class="math notranslate nohighlight">\(m\)</span> Nebenbedingungen</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\sum_{j=1}^na_{ij}x_j \leq b_i
\end{align*}\]</div>
<p>verbietet also einen Halbraum von <span class="math notranslate nohighlight">\(\RR^n\)</span> für die Menge der zulässigen Lösungen. Wir fragen uns, ob immer alle Nebenbedingungen nötig sind, um eine optimale Lösung zu finden.</p>
<div class="proof example admonition" id="example-7">
<p class="admonition-title"><span class="caption-number">Example 13.7 </span></p>
<section class="example-content" id="proof-content">
<p>TO DO</p>
</section>
</div><div class="proof definition admonition" id="definition-8">
<p class="admonition-title"><span class="caption-number">Definition 13.2 </span> (Bindende Nebenbedingung)</p>
<section class="definition-content" id="proof-content">
<p>Sei <span class="math notranslate nohighlight">\(P=\{x \in \RR^n \mid Ax \leq b\}\)</span> ein Polyeder und <span class="math notranslate nohighlight">\(\overline x=(\overline x_1, \overline x_2, \ldots, \overline x_n)^T \in P\)</span>. Dann heißt die Nebenbedingung
<span class="math notranslate nohighlight">\(
\sum_{j=1}^na_{ij}x_j \leq b_i
\)</span> <em>bindend</em> für <span class="math notranslate nohighlight">\(\overline x\)</span>, falls</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\sum_{j=1}^na_{ij}\overline x_j = b_i.
\end{align*}\]</div>
</section>
</div><p>Eine Nebenbedingung ist also nur (lokal) einschränkend für einen Punkt <span class="math notranslate nohighlight">\(x\)</span> in Optimierungsrichtung, falls Sie auch bindend ist.</p>
<p>Gemischt-ganzzahlige Programme werden typischerweise über Branch-And-Bound Verfahren gelöst. Es kann sein, dass viele Nebenbedingungen für keine der zulässigen Lösungen, die während des Branch-And-Bound Verfahrens besucht werden, bindend ist.</p>
<div class="proof example admonition" id="example-9">
<p class="admonition-title"><span class="caption-number">Example 13.8 </span></p>
<section class="example-content" id="proof-content">
<p>TO DO</p>
</section>
</div><p>Leider kann man diese Nebenbedingungen nicht einfach komplett ignorieren, da vorab unbekannt ist, welche Nebenbedingungen für den Lösungsprozess nicht benötigt werden.
Wie können wir trotzdem ausnutzen, wenn viele Nebenbedingungen nicht bindend werden?</p>
<p>Wir teilen die Menge <span class="math notranslate nohighlight">\(R\)</span> der Nebenbedingungen auf in eine Menge von <span class="math notranslate nohighlight">\(R_{\initial}\)</span> von “essentiellen” Nebenbedingungen, sowie eine Menge <span class="math notranslate nohighlight">\(R_{\lazy}\)</span> von Nebenbedingungen, bei denen wir davon ausgehen, dass nur ein sehr kleiner Teil tatsächlich im Verlauf des Lösungsverfahrens bindend wird. Wir starten dann ein normales Branch-And-Bound Verfahren auf dem reduzierten Model, das nur die essentiellen Nebenbedingungen enthält. Wann immer eine zulässige Lösung <span class="math notranslate nohighlight">\(x\)</span> gefunden wird, müssen wir überprüfen ob <span class="math notranslate nohighlight">\(x\)</span>  Nebenbedingungen aus <span class="math notranslate nohighlight">\(R_{\lazy}\)</span> verletzt. Falls dies so ist, werden diese zum aktuellen Modell hinzugefügt. Danach wird mit dem  Branch-And-Bound Verfahren fortgefahren.</p>
<p>Insgesamt ergibt sich folgendes Vorgehen:</p>
<div class="proof algorithm admonition" id="algorithm-10">
<p class="admonition-title"><span class="caption-number">Algorithm 13.1 </span> (Branch-And-Bound Verfahren mit Lazy Constraints)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>Eingabe:</strong></p>
<ul class="simple">
<li><p>Gemischt-ganzzahliges Programm <span class="math notranslate nohighlight">\(\ILP\)</span> mit Nebenbedingungen <span class="math notranslate nohighlight">\(R=R_{\initial} \cup R_{\lazy}\)</span></p></li>
</ul>
<p><strong>Verfahren:</strong></p>
<ul class="simple">
<li><p>Starte das Branch-And-Bound Verfahren für <span class="math notranslate nohighlight">\(\ILP\)</span> mit Nebenbedingungen <span class="math notranslate nohighlight">\(R_{\reduced} := R_{\initial}\)</span>.</p>
<ul>
<li><p>Wann immer einer zulässige Lösung <span class="math notranslate nohighlight">\(x\)</span> gefunden wurde</p>
<ul>
<li><p>Prüfe ob <span class="math notranslate nohighlight">\(x\)</span> eine Nebenbedingung in <span class="math notranslate nohighlight">\(R_{\lazy}\)</span> verletzt</p></li>
<li><p>Füge jede Nebenbedingung aus <span class="math notranslate nohighlight">\(R_{\lazy}\)</span> die durch <span class="math notranslate nohighlight">\(x\)</span> verletzt wird zu <span class="math notranslate nohighlight">\(R_{\reduced}\)</span> hinzu</p></li>
<li><p>Fahre mit dem Branch-And-Bound Verfahren fort</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
</div><p>Um das Verfahren praktisch umzusetzen muss nicht unbedingt das Branch-And-Bound Verfahren selbst implementiert werden, sondern nur die Prüfroutine für die Verletzung der Nebenbedingungen. Viele Solver unterstützen dies über sogenannte <em>Callback-Funktionen</em>.</p>
<section id="beispiel-traveling-salesman-problem">
<h4><span class="section-number">13.3.5.1. </span>Beispiel: Traveling Salesman Problem<a class="headerlink" href="#beispiel-traveling-salesman-problem" title="Link zu dieser Überschrift">#</a></h4>
<p>Wir betrachten das Vorgehen am Beispiel der Formulierung nach Dantzig, Fulkerson und Johnson für das Traveling Salesman Problem (siehe Abschnitt <a class="reference internal" href="09_Standardprobleme.html#subsubsec-tsp"><span class="std std-ref">Das Problem des Handelsreisenden</span></a>).</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{alignat*}{5}
\min          &amp; \quad  &amp;   \sum_{i,j=1\ldots, n; i\not=j} &amp; d_{ij}x_{ij}         &amp; &amp; \\[4mm]
\text{s.t. } &amp; &amp;  \sum_{j=1\ldots n, \ i \not=j}x_{ij} &amp; =   1 &amp;&amp; \quad\quad &amp; &amp; \forall i= 1, \ldots, n \\[2mm]
 &amp; &amp;  \sum_{i=1\ldots n, \ i \not=j}x_{ij} &amp; =   1 &amp;&amp; \quad\quad &amp; &amp; \forall j= 1, \ldots, n \\[2mm]
&amp; &amp; \sum_{i \in C'} \sum_{j \in C'}x_{ij} &amp; \leq   |S|-1 &amp;&amp; \quad\quad &amp; &amp; \forall C' \subset \{2, \ldots, n\}, \hspace{0.3cm} |C'| \geq 2 \\[2mm]
&amp; &amp; x_{ij} &amp; \in  \BB &amp;&amp; &amp;&amp; \forall i,j= 1, \ldots, n.
\end{alignat*}\]</div>
<p>Die ersten beiden Klassen von Nebenbedingungen stellen sicher, dass jeder Ort genau einmal besucht und wieder verlassen wird. Bei <span class="math notranslate nohighlight">\(n\)</span> Orten gibt es je <span class="math notranslate nohighlight">\(n\)</span> Nebenbedingungen von jeder Klasse. Mit Hinblick auf den Rechenaufwand ist dies unproblematisch. Wir betrachten beide Klassen als essentiell. Diese Nebenbedingungen bilden die Menge <span class="math notranslate nohighlight">\(R_{\initial}\)</span>.</p>
<p>Die dritte Klasse von Nebenbedingungen verhindert Subtouren. Diese Nebenbedingungen bilden die Menge <span class="math notranslate nohighlight">\(R_{\lazy}\)</span>. Es gibt eine Nebenbedingung pro möglicher Subtour. Dies sind insgesamt <span class="math notranslate nohighlight">\(2^{n-1}\)</span> Nebenbedingungen. Selbst für relativ kleine Werte von <span class="math notranslate nohighlight">\(n\)</span> sprengt dies die Möglichkeiten moderner Computer. Wir gehen davon aus, dass nur vergleichsweise wenige Subtouren im Lösungsprozess wirklich relevant werden. Dies Annahme legt die Nutzung als Lazy Constraint nahe.</p>
<figure class="align-default" id="tsp-loesungmitsubtouren">
<a class="reference internal image-reference" href="_images/TSP-LoesungMitSubtouren.png"><img alt="_images/TSP-LoesungMitSubtouren.png" src="_images/TSP-LoesungMitSubtouren.png" style="height: 300px;" /></a>
</figure>
<p>Es bleibt noch die Frage zu klären, wie wir für eine gegebene Lösung <span class="math notranslate nohighlight">\(x\)</span> effizient überprüfen, ob eine der Subtour-Eliminationsbedingungen verletzt wird. Falls alle <span class="math notranslate nohighlight">\(2^{n-1}\)</span> Bedingungen erstellt und einzeln überprüft werden müssten, wird das Verfahren extrem langsam und nicht sinnvoll.</p>
<p>Für eine gegebene Lösung <span class="math notranslate nohighlight">\(x\)</span> können wir den Nachfolger eines Ortes <span class="math notranslate nohighlight">\(k\)</span> in der Tour oder Subtour bestimmen durch</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\text{Nachfolger}(k)=l \text{ mit der Eigenschaft } x_{kl}=1
\end{align*}\]</div>
<div class="proof example admonition" id="example-11">
<p class="admonition-title"><span class="caption-number">Example 13.9 </span></p>
<section class="example-content" id="proof-content">
<p>TO DO</p>
</section>
</div><p>Wir können die Überprüfung effizient mit folgendem Algorithmus vornehmen:</p>
<div class="proof algorithm admonition" id="algo:findeSubtour">
<p class="admonition-title"><span class="caption-number">Algorithm 13.2 </span> (Überprüfe auf Subtouren in Lösung <span class="math notranslate nohighlight">\(x\)</span>)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>Input</strong>: Mögliche Lösung <span class="math notranslate nohighlight">\(x\)</span></p>
<p><strong>Output</strong>: Subtour falls existent</p>
<p>Startort=0</p>
<p>AktuellerOrt = Nachfolger(Startort)</p>
<p>Tour=[Startort, AktuellerOrt]</p>
<p><strong>while</strong> <em>AktuellerOrt <span class="math notranslate nohighlight">\(\neq=\)</span> Startort</em> <strong>do</strong></p>
<p>AktuellerOrt = Nachfolger(Startort)</p>
<p>Füge AktuellerOrt an Tour an</p>
<p><strong>if</strong> <em>Tour beinhaltet nicht alle Orte</em> <strong>then</strong></p>
<p>Subtour Tour gefunden</p>
</section>
</div><p>Der Algorithmus findet auf jeden Fall eine Subtour falls eine solche in <span class="math notranslate nohighlight">\(x\)</span> existiert. Eine leicht abgewandelte Version des Vorgehens kann auch alle möglichen vorhandenen Subtouren finden.</p>
<div class="proof example admonition" id="example-13">
<p class="admonition-title"><span class="caption-number">Example 13.10 </span></p>
<section class="example-content" id="proof-content">
<p>TO DO</p>
</section>
</div><figure class="align-default" id="tsp-lazy-constraints">
<a class="reference internal image-reference" href="_images/TSP-lazy-constraints.png"><img alt="_images/TSP-lazy-constraints.png" src="_images/TSP-lazy-constraints.png" style="height: 300px;" /></a>
<figcaption>
<p><span class="caption-number">Abb. 13.3 </span><span class="caption-text">Eine TSP-Instanz mit 50 Orten. Die Grafik zeigt alle 36 Zwischenlösungen, die bei einem Branch-And-Bound Verfahren mit Lazy-Constraints gefunden werden.</span><a class="headerlink" href="#tsp-lazy-constraints" title="Link zu diesem Bild">#</a></p>
</figcaption>
</figure>
</section>
</section>
</section>
<section id="interpretation-der-solver-ausgaben">
<h2><span class="section-number">13.4. </span>Interpretation der Solver-Ausgaben<a class="headerlink" href="#interpretation-der-solver-ausgaben" title="Link zu dieser Überschrift">#</a></h2>
<p>Die Ausgaben des Lösers liefern wichtige diagnostische Informationen.
Im Folgenden sehen wir die Ausgaben für das Modell aus Abschnitt <a class="reference internal" href="#subsub-lazyconstraints"><span class="std std-ref">Lazy Constraints</span></a>.</p>
<figure class="align-default" id="gurobi-solveroutput2-1">
<img alt="_images/Gurobi_SolverOutput2_1.png" src="_images/Gurobi_SolverOutput2_1.png" />
</figure>
<p>Wir sehen, dass das Modell <span class="math notranslate nohighlight">\(2550\)</span> Entscheidungsvariablen enthält von denen <span class="math notranslate nohighlight">\(0\)</span> kontinuierlich, <span class="math notranslate nohighlight">\(1250\)</span> binär und <span class="math notranslate nohighlight">\(1250\)</span> ganzzahlig sind.
Die Matrix <span class="math notranslate nohighlight">\(A\)</span> besteht aus 50 Zeilen und 1275 Spalten - es sind aber nur 2500 Einträge ungleich <span class="math notranslate nohighlight">\(0\)</span>.
Wir vergleichen diese Zahlen mit den von uns erwarteten Werten.
Dies ist ein erster einfacher Test, ob das Modell richtig implementiert ist.
Wir erkennen zusätzlich, dass Lazy Constraints aktiv sind.</p>
<figure class="align-default" id="gurobi-solveroutput2-2">
<img alt="_images/Gurobi_SolverOutput2_2.png" src="_images/Gurobi_SolverOutput2_2.png" />
</figure>
<p>Alls vorkommenden Zahlen liegen jeweils in der gleichen Größenordnung.
Wäre das berichtete Intervall für eine Kategorie sehr groß, wäre dies in Hinweis auf mögliche spätere numerische Probleme beim Lösen des linearen Programms.</p>
<figure class="align-default" id="gurobi-solveroutput2-3">
<img alt="_images/Gurobi_SolverOutput2_3.png" src="_images/Gurobi_SolverOutput2_3.png" />
</figure>
<p>Der Solver hat über eine Heuristik eine erste zulässge Lösung gefunden bevor mit dem eigentlichen Lösungsprozess gestartet wurde.
Wir wissen also, dass die optimale Lösung einen Zielfunktionswert von höchstens 2775.3416544 hat.
Dieser Wert wird als obere Schranke für den weiteren Lösungsprozess benutzt und kann damit den Lösungsprozess beschleunigen.</p>
<p>Wird vorab keine zulässige Lösung gefunden, kann der Lösungsprozess möglicherweise beschleunigt werden, indem man durch Kenntnis des konkreten Problems mit wenig Rechenaufwand außerhalb des gemischt-ganzzahligen Modells eine zulässige Lösung findet und dem Solver vorab übermittelt. Dieses Vorgehen ist allerdings nicht immer möglich.</p>
<figure class="align-default" id="gurobi-solveroutput2-4">
<img alt="_images/Gurobi_SolverOutput2_4.png" src="_images/Gurobi_SolverOutput2_4.png" />
</figure>
<p>Die Presolve-Routine hat das Modell etwas verkleinern können. Die Modellgröße nach der Presolve-Routine ist ein guter Kennwert für die Größe des Modells.</p>
<figure class="align-default" id="gurobi-solveroutput2-5">
<img alt="_images/Gurobi_SolverOutput2_5.png" src="_images/Gurobi_SolverOutput2_5.png" />
</figure>
<p>Der Löser startet nun mit der eigentlichen Suche. Zu Beginn des Suchbaums wird das relaxierte Problem gelöst (die sogenannte root relaxation).
Diese ergibt in 71 Iterationen die untere Schranke von 598.1996.</p>
<p>Die Lösungsdauer der Root Relaxation ist mit 0.01 Sekunden unkritisch.
Bei einer deutlich längeren Rechenzeit würden zusätzliche diagnostische Informationen zur Root Relaxation angezeigt werden.</p>
<figure class="align-default" id="gurobi-solveroutput2-6">
<img alt="_images/Gurobi_SolverOutput2_6.png" src="_images/Gurobi_SolverOutput2_6.png" />
</figure>
<p>Dieser Teil beschreibt den Verlauf des Branch-And-Bound Verfahrens. In festen Zeitabständen wird eine neue Zeile generiert, die Aufschluss über den aktuellen Zustand des aktuellen Suchbaums gibt.
Die Spalten bedeuten im Einzelnen</p>
<ul class="simple">
<li><p>Die 1. Spalte enthält ein h oder ein * falls seit der letzten Zeile eine neue zulässige Lösung gefunden wurde.</p></li>
<li><p>Die 2. Spalte enthält die Anzahl der fertig abgearbeiteten Knoten im Suchbaum.</p></li>
<li><p>Die 3. Spalte enthält die Anzahl der noch zu bearbeitenden Blätter im Suchbaum.</p></li>
<li><p>Die Spalten 4-6 beschreiben den aktuell bearbeiteten Knoten im Suchbaum.</p>
<ul>
<li><p>Der Wert der Relaxierung,</p></li>
<li><p>Die Tiefe im Suchbaum,</p></li>
<li><p>Die Anzahl der fraktionalen ganzzahligen Variablen.</p></li>
</ul>
</li>
<li><p>Die Spalten 7-9 beschreiben die Güte der bisher gefundenen Lösung.</p>
<ul>
<li><p>Der Lösungswert der besten bisher gefundenen zulässigen Lösung,</p></li>
<li><p>Die beste bisher bewiesene Schranke,</p></li>
<li><p>Der Wert (<span class="math notranslate nohighlight">\(|\)</span>beste gefundene Lösung - beste gefundene Schranke<span class="math notranslate nohighlight">\(|\)</span>) / beste gefundene Lösung.</p></li>
</ul>
</li>
<li><p>Die 10. Spalte zeigt die Anzahl der durchschnittlichen Simplex-Operationen pro Knoten.</p></li>
<li><p>Die 11. Spalte zeigt die Laufzeit des Branch-And-Bound Verfahrens bis zum aktuellen Stand.</p></li>
</ul>
<figure class="align-default" id="gurobi-solveroutput2-7">
<img alt="_images/Gurobi_SolverOutput2_7.png" src="_images/Gurobi_SolverOutput2_7.png" />
</figure>
<p>Der Löser hat während des Lösungsprozesses zusätzliche Nebenbedingungen, sogenannte Schnittebenen (\emph{cuts}) hinzugefügt, die die optimale Lösung nicht ändern, aber zu einem schnelleren Lösungsprozess führen sollen. Die Aufschlüsselung dieser folgt nach verschiedenen Klassen von Schnittebenen.</p>
<p>Außerdem wurden insgesamt 8 Lazy-Constraints hinzugefügt. Durch die geringe nötige Anzahl an Lazy-Constraints erkennt man, dass der Einsatz von diesen für die aktuelle Instanz sinnvoll ist.</p>
<figure class="align-default" id="gurobi-solveroutput2-8">
<img alt="_images/Gurobi_SolverOutput2_8.png" src="_images/Gurobi_SolverOutput2_8.png" />
</figure>
<p>Der fertige Branch-And-Bound Baum besteht aus 22 Knoten.
Insgesamt wurden 494 Simplex-Schritte an den Knoten ausgeführt.
Es wurden alle 8 Kerne benutzt.
Die Rechenzeit für das Branch-And-Bound Verfahren war 0.48 Sekunden.
Insgesamt wurden während des Lösungsprozesses 7 zulässige Lösungen im Zahlenbereich von 635 bis 2775 gefunden.</p>
<figure class="align-default" id="gurobi-solveroutput2-9">
<img alt="_images/Gurobi_SolverOutput2_9.png" src="_images/Gurobi_SolverOutput2_9.png" />
</figure>
<p>Es gilt</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\frac{|\text{Wert der besten gefundenen Lösung - Wert der schärfsten unteren Schranke}|}{|\text{Wert der besten gefundenen Lösung}|} =0
\end{align*}\]</div>
<p>Damit wurde die optimale Lösung gefunden.
Als Abbruchtoleranz war <span class="math notranslate nohighlight">\(0.0004\)</span> eingestellt, d.h. das Lösungsverfahren bricht ab, wenn dieser Quotient kleiner als <span class="math notranslate nohighlight">\(0.0004\)</span> ist.
Die bis dahin gefundene beste zulässige Lösung wird dann als Ergebnis gemeldet, ist aber möglicherweise nicht optimal.</p>
<p>Die gefundene Lösung hat einen Zielfunktionswert von 635.5025787588.
Die beste gefundene untere Schranke für den Zielfunktionswert ist 635.5025787588.</p>
<p>Auf der nächsten Seite findet sich die komplette Ausgabe für das Modell.</p>
<figure class="align-default" id="gurobi-solveroutput2">
<img alt="_images/Gurobi_SolverOutput2.png" src="_images/Gurobi_SolverOutput2.png" />
</figure>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="12_Ablaufplanung.html" title="zurück Seite">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">zurück</p>
            <p class="prev-next-title"><span class="section-number">12. </span>Ablaufplanung</p>
        </div>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Dennis Janka<br/>
  
      &copy; Copyright 2023.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>